%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}


\usepackage{charter}
\usepackage[defaultsans]{lato}
\usepackage{inconsolata}


\title{KLayout Photonic PCells Documentation}
\date{Aug 11, 2019}
\release{1.0.5}
\author{Sebastian Goeldi}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


KLayout Photonic PCells introduces the concept of ports to KLayout. Ports in contrast to pins also track directions. Additionally, PCells can be built hierarchically from other PCells and new shapes. The sub-cells can be connected to each other through ports.

The source code can be found on \sphinxhref{https://github.com/sebastian-goeldi/KLayoutPhotonicPCells-core}{Github}%
\begin{footnote}[1]\sphinxAtStartFootnote
\sphinxnolinkurl{https://github.com/sebastian-goeldi/KLayoutPhotonicPCells-core}
%
\end{footnote}


\chapter{Introduction}
\label{\detokenize{introduction:introduction}}\label{\detokenize{introduction::doc}}
The KLayoutPhotonicPCells{}`kppc{}` module is an extension for KLayout PCells to facilitate photonic PCells.
Photonics often works with the concept of ports.
Ports are defined by a coordinate and a direction. In the case of this module ports will be stored in PCell parameters in the background.
They are serialized \sphinxhref{https://www.klayout.de/doc/code/class\_ICplxTrans.html}{KLayout Trans}%
\begin{footnote}[2]\sphinxAtStartFootnote
\sphinxnolinkurl{https://www.klayout.de/doc/code/class\_ICplxTrans.html}
%
\end{footnote} objects. For an introduction on how to build your own PCell Library, have a look at
how to create {\hyperref[\detokenize{photonics/example_library::doc}]{\sphinxcrossref{\DUrole{doc}{Example Library}}}}.

When building PCell Libraries it is recommended to build it with three packages as shown in \hyperref[\detokenize{introduction:p-format}]{Fig.\@ \ref{\detokenize{introduction:p-format}}}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{package_format}.png}
\caption{The recommend structure for working with the photonic PCell extension:
* Photonic Library Extension: New functionalities for KLayout PCells}\label{\detokenize{introduction:p-format}}
\begin{sphinxlegend}\begin{itemize}
\item {} 
Ports, DR-Cleaning, DataPrep

\end{itemize}
\begin{itemize}
\item {} 
Technology: Contains manufacturer specific data
\begin{itemize}
\item {} 
Design rules

\item {} 
Layermapping from abstract to manufacturer layers

\end{itemize}

\item {} 
PCell-Library:
\begin{itemize}
\item {} 
Definitions of PCells

\item {} 
Library specific modules if required

\end{itemize}

\end{itemize}
\end{sphinxlegend}
\end{figure}


\chapter{First Steps}
\label{\detokenize{photonics/first_steps:first-steps}}\label{\detokenize{photonics/first_steps::doc}}

\section{Prerequisites}
\label{\detokenize{photonics/first_steps:prerequisites}}
To use the library extension, make sure you have installed Cython. Part of the cleaning process relies on a C++ module that needs to be compiled first. To compile it we use pythons \sphinxhref{https://setuptools.readthedocs.io/en/latest/index.html}{\DUrole{xref,std,std-doc}{Setuptools}}%
\begin{footnote}[3]\sphinxAtStartFootnote
\sphinxnolinkurl{https://setuptools.readthedocs.io/en/latest/index.html}
%
\end{footnote} and \sphinxhref{https://cython.readthedocs.io/en/latest/index.html}{\DUrole{xref,std,std-doc}{Cython}}%
\begin{footnote}[4]\sphinxAtStartFootnote
\sphinxnolinkurl{https://cython.readthedocs.io/en/latest/index.html}
%
\end{footnote}. Make sure you have these packages before starting. It is sufficient to install Cython, as setuptools is either built-in of python or installed along Cython.


\section{Installation}
\label{\detokenize{photonics/first_steps:installation}}
This installation procedure is solely written for Linux. For this installation Cython is required. So get Cython either from the package manager of your distribution or through pip. The package is tested on Python 3.5+. No special python3 modules are used, therefore it should work with python 2.7, too. The Python version used should be the same KLayout uses. By default, this is the system interpreter for Python3.
If you installed the package manually, move the unpackaged package into \sphinxcode{\sphinxupquote{\textasciitilde{}/.klayout/salt}} or into the KLayout folder if you used a custom directory. This tutorial assumes default pathes.
After unpacking and moving you should have a \sphinxcode{\sphinxupquote{\textasciitilde{}/.klayout/salt/KLayouPhotonicPCells/core}} folder. If you installed the FreePDK45\_Cells \& FreePDK45\_tech, then you should have the folders \sphinxcode{\sphinxupquote{\textasciitilde{}/.klayout/salt/KLayouPhotonicPCells/FreePDK45\_ExampleCells}} and \sphinxcode{\sphinxupquote{\textasciitilde{}/.klayout/salt/KLayouPhotonicPCells/FreePDK45\_tech}}, too. The library extension package needs manual setup before being usable.

Use a console and execute the following commands. If you are familiar with setuptools you can skip these instructions. For further information consult the \sphinxcode{\sphinxupquote{drc}} documentation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{cd \PYGZti{}/.klayout/salt/KLayouPhotonicPCells/cor/python/kppc/drc/}
\PYG{g+go}{sh compile.sh}
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{Cython}.png}
\caption{Change directory to the drc folder and execute the setup script.}\label{\detokenize{photonics/first_steps:id1}}\end{figure}


\chapter{Ports}
\label{\detokenize{photonics/ports:ports}}\label{\detokenize{photonics/ports::doc}}
Ports are a concept used in photonics. They are very similar to pins in electronics, as they both describe connections
between cells. The big difference between ports and pins is ports have additional properties that are important
for photonics. When connecting photonic devices it is necessary that the device connections are aligned. For example, if
two waveguides are connected, the connected endings have to point on the opposite direction and the connections have to
be the same size.

This module implements the concept of ports into KLayout PCells. Currently ports track location, orientation and length.
If two ports have a mismatch in width, they cannot be connected. New ports can be created in PCells with the
{\hyperref[\detokenize{photonics/photonics:kppc.photonics.PortCreation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{kppc.photonics.PortCreation}}}}} when overriding the {\hyperref[\detokenize{photonics/photonics:kppc.photonics.PhotDevice.create_param_inst}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{kppc.photonics.PhotDevice.create\_param\_inst()}}}}} method
in the PCell Library. If any instantiated child cells in a PCell have any open ports (not connected to another port of another
child cell), they are passed upwards to the cell itself and are announced as ports of this cell.
This hierarchical design allows to create arbitrary Devices independent of the order when assembling them.

\begin{sphinxadmonition}{note}{Note:}
Make sure ports are drawn correctly. If texts in ports aren’t oriented alond the width of the port, set the boolean
\sphinxtitleref{Transform text with cell instance} in \sphinxmenuselection{File \(\rightarrow\) Setup \(\rightarrow\) Display \(\rightarrow\) Cells} to true
and make sure the text font is not set to the default font.
\end{sphinxadmonition}


\chapter{Technology Import}
\label{\detokenize{photonics/techfile:technology-import}}\label{\detokenize{photonics/techfile::doc}}
To use KLayout and the Photonics-extension efficiently, it is recommended to create a KLayout technology. This chapter explains how to import a technology.

To use a new technology either create a new technology from the technology manager \sphinxmenuselection{Tools \(\rightarrow\) Manage Technologies} or create a new package
\sphinxmenuselection{Tools \(\rightarrow\) Manage Packages} for the technology.


\section{Import Techfile \& Creation of LayerProperties}
\label{\detokenize{photonics/techfile:import-techfile-creation-of-layerproperties}}
KLayout provides an import script for Cadence techfiles. This import creats the Layer Properties automatically for the defined layers.

The script can be found in \sphinxmenuselection{File \(\rightarrow\) Import Cadence Techfile}

After importing, the properties can be saved via \sphinxmenuselection{File \(\rightarrow\) Save Layer Properties}. Recommended location for the file is in the technology folder in \sphinxtitleref{\textasciitilde{}/.klayout/tech/\textless{}technology-name\textgreater{}/\textless{}file\textgreater{}} or if using a package
\sphinxtitleref{\textasciitilde{}/.klayout/salt/\textless{}technology-package\textgreater{}/tech/\textless{}filename\textgreater{}}

\begin{sphinxadmonition}{note}{Note:}
Suggested filename for easy use with the sample cells: FreePDK45.tf / FreePDK45.lyp

In order to use the additional abstract layers in the sample cells paste the following xml snippets into the \textless{}\textgreater{}.lyp file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{\PYGZlt{}properties}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}frame\PYGZhy{}color}\PYG{n+nt}{\PYGZgt{}}\PYGZsh{}01ff6b\PYG{n+nt}{\PYGZlt{}/frame\PYGZhy{}color\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}fill\PYGZhy{}color}\PYG{n+nt}{\PYGZgt{}}\PYGZsh{}01ff6b\PYG{n+nt}{\PYGZlt{}/fill\PYGZhy{}color\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}frame\PYGZhy{}brightness}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/frame\PYGZhy{}brightness\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}fill\PYGZhy{}brightness}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/fill\PYGZhy{}brightness\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}dither\PYGZhy{}pattern}\PYG{n+nt}{\PYGZgt{}}I3\PYG{n+nt}{\PYGZlt{}/dither\PYGZhy{}pattern\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}line\PYGZhy{}style}\PYG{n+nt}{\PYGZgt{}}I6\PYG{n+nt}{\PYGZlt{}/line\PYGZhy{}style\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}valid}\PYG{n+nt}{\PYGZgt{}}true\PYG{n+nt}{\PYGZlt{}/valid\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}visible}\PYG{n+nt}{\PYGZgt{}}true\PYG{n+nt}{\PYGZlt{}/visible\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}transparent}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/transparent\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}width}\PYG{n+nt}{\PYGZgt{}}1\PYG{n+nt}{\PYGZlt{}/width\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}marked}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/marked\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}xfill}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/xfill\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}animation}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/animation\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}name}\PYG{n+nt}{\PYGZgt{}}phot\PYGZus{}silicon.drawing\PYG{n+nt}{\PYGZlt{}/name\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}source}\PYG{n+nt}{\PYGZgt{}}400/0@1\PYG{n+nt}{\PYGZlt{}/source\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/properties\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}properties}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}frame\PYGZhy{}color}\PYG{n+nt}{\PYGZgt{}}\PYGZsh{}808080\PYG{n+nt}{\PYGZlt{}/frame\PYGZhy{}color\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}fill\PYGZhy{}color}\PYG{n+nt}{\PYGZgt{}}\PYGZsh{}808080\PYG{n+nt}{\PYGZlt{}/fill\PYGZhy{}color\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}frame\PYGZhy{}brightness}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/frame\PYGZhy{}brightness\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}fill\PYGZhy{}brightness}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/fill\PYGZhy{}brightness\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}dither\PYGZhy{}pattern}\PYG{n+nt}{\PYGZgt{}}I2\PYG{n+nt}{\PYGZlt{}/dither\PYGZhy{}pattern\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}line\PYGZhy{}style}\PYG{n+nt}{\PYGZgt{}}I0\PYG{n+nt}{\PYGZlt{}/line\PYGZhy{}style\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}valid}\PYG{n+nt}{\PYGZgt{}}true\PYG{n+nt}{\PYGZlt{}/valid\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}visible}\PYG{n+nt}{\PYGZgt{}}true\PYG{n+nt}{\PYGZlt{}/visible\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}transparent}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/transparent\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}width}\PYG{n+nt}{\PYGZgt{}}1\PYG{n+nt}{\PYGZlt{}/width\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}marked}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/marked\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}xfill}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/xfill\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}animation}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/animation\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}name}\PYG{n+nt}{\PYGZgt{}}phot\PYGZus{}poly.drawing\PYG{n+nt}{\PYGZlt{}/name\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}source}\PYG{n+nt}{\PYGZgt{}}410/0@1\PYG{n+nt}{\PYGZlt{}/source\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/properties\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}properties}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}frame\PYGZhy{}color}\PYG{n+nt}{\PYGZgt{}}\PYGZsh{}ff0000\PYG{n+nt}{\PYGZlt{}/frame\PYGZhy{}color\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}fill\PYGZhy{}color}\PYG{n+nt}{\PYGZgt{}}\PYGZsh{}ff0000\PYG{n+nt}{\PYGZlt{}/fill\PYGZhy{}color\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}frame\PYGZhy{}brightness}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/frame\PYGZhy{}brightness\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}fill\PYGZhy{}brightness}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/fill\PYGZhy{}brightness\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}dither\PYGZhy{}pattern}\PYG{n+nt}{\PYGZgt{}}I9\PYG{n+nt}{\PYGZlt{}/dither\PYGZhy{}pattern\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}line\PYGZhy{}style}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}valid}\PYG{n+nt}{\PYGZgt{}}true\PYG{n+nt}{\PYGZlt{}/valid\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}visible}\PYG{n+nt}{\PYGZgt{}}true\PYG{n+nt}{\PYGZlt{}/visible\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}transparent}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/transparent\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}width}\PYG{n+nt}{\PYGZgt{}}1\PYG{n+nt}{\PYGZlt{}/width\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}marked}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/marked\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}xfill}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/xfill\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}animation}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/animation\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}name}\PYG{n+nt}{\PYGZgt{}}phot\PYGZus{}pwell.drawing\PYG{n+nt}{\PYGZlt{}/name\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}source}\PYG{n+nt}{\PYGZgt{}}420/0@1\PYG{n+nt}{\PYGZlt{}/source\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/properties\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}properties}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}frame\PYGZhy{}color}\PYG{n+nt}{\PYGZgt{}}\PYGZsh{}0000ff\PYG{n+nt}{\PYGZlt{}/frame\PYGZhy{}color\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}fill\PYGZhy{}color}\PYG{n+nt}{\PYGZgt{}}\PYGZsh{}0000ff\PYG{n+nt}{\PYGZlt{}/fill\PYGZhy{}color\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}frame\PYGZhy{}brightness}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/frame\PYGZhy{}brightness\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}fill\PYGZhy{}brightness}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/fill\PYGZhy{}brightness\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}dither\PYGZhy{}pattern}\PYG{n+nt}{\PYGZgt{}}I5\PYG{n+nt}{\PYGZlt{}/dither\PYGZhy{}pattern\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}line\PYGZhy{}style}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}valid}\PYG{n+nt}{\PYGZgt{}}true\PYG{n+nt}{\PYGZlt{}/valid\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}visible}\PYG{n+nt}{\PYGZgt{}}true\PYG{n+nt}{\PYGZlt{}/visible\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}transparent}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/transparent\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}width}\PYG{n+nt}{\PYGZgt{}}1\PYG{n+nt}{\PYGZlt{}/width\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}marked}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/marked\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}xfill}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/xfill\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}animation}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/animation\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}name}\PYG{n+nt}{\PYGZgt{}}phot\PYGZus{}nwell.drawing\PYG{n+nt}{\PYGZlt{}/name\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}source}\PYG{n+nt}{\PYGZgt{}}430/0@1\PYG{n+nt}{\PYGZlt{}/source\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/properties\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}properties}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}frame\PYGZhy{}color}\PYG{n+nt}{\PYGZgt{}}\PYGZsh{}ff0000\PYG{n+nt}{\PYGZlt{}/frame\PYGZhy{}color\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}fill\PYGZhy{}color}\PYG{n+nt}{\PYGZgt{}}\PYGZsh{}ff0000\PYG{n+nt}{\PYGZlt{}/fill\PYGZhy{}color\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}frame\PYGZhy{}brightness}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/frame\PYGZhy{}brightness\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}fill\PYGZhy{}brightness}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/fill\PYGZhy{}brightness\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}dither\PYGZhy{}pattern}\PYG{n+nt}{\PYGZgt{}}I11\PYG{n+nt}{\PYGZlt{}/dither\PYGZhy{}pattern\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}line\PYGZhy{}style}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}valid}\PYG{n+nt}{\PYGZgt{}}true\PYG{n+nt}{\PYGZlt{}/valid\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}visible}\PYG{n+nt}{\PYGZgt{}}true\PYG{n+nt}{\PYGZlt{}/visible\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}transparent}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/transparent\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}width}\PYG{n+nt}{\PYGZgt{}}1\PYG{n+nt}{\PYGZlt{}/width\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}marked}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/marked\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}xfill}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/xfill\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}animation}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/animation\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}name}\PYG{n+nt}{\PYGZgt{}}phot\PYGZus{}pimplant.drawing\PYG{n+nt}{\PYGZlt{}/name\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}source}\PYG{n+nt}{\PYGZgt{}}440/0@1\PYG{n+nt}{\PYGZlt{}/source\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/properties\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}properties}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}frame\PYGZhy{}color}\PYG{n+nt}{\PYGZgt{}}\PYGZsh{}0000ff\PYG{n+nt}{\PYGZlt{}/frame\PYGZhy{}color\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}fill\PYGZhy{}color}\PYG{n+nt}{\PYGZgt{}}\PYGZsh{}0000ff\PYG{n+nt}{\PYGZlt{}/fill\PYGZhy{}color\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}frame\PYGZhy{}brightness}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/frame\PYGZhy{}brightness\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}fill\PYGZhy{}brightness}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/fill\PYGZhy{}brightness\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}dither\PYGZhy{}pattern}\PYG{n+nt}{\PYGZgt{}}I7\PYG{n+nt}{\PYGZlt{}/dither\PYGZhy{}pattern\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}line\PYGZhy{}style}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}valid}\PYG{n+nt}{\PYGZgt{}}true\PYG{n+nt}{\PYGZlt{}/valid\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}visible}\PYG{n+nt}{\PYGZgt{}}true\PYG{n+nt}{\PYGZlt{}/visible\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}transparent}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/transparent\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}width}\PYG{n+nt}{\PYGZgt{}}1\PYG{n+nt}{\PYGZlt{}/width\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}marked}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/marked\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}xfill}\PYG{n+nt}{\PYGZgt{}}false\PYG{n+nt}{\PYGZlt{}/xfill\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}animation}\PYG{n+nt}{\PYGZgt{}}0\PYG{n+nt}{\PYGZlt{}/animation\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}name}\PYG{n+nt}{\PYGZgt{}}phot\PYGZus{}nimplant.drawing\PYG{n+nt}{\PYGZlt{}/name\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}source}\PYG{n+nt}{\PYGZgt{}}450/0@1\PYG{n+nt}{\PYGZlt{}/source\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/properties\PYGZgt{}}
\end{sphinxVerbatim}

Put this block between the last properties block but befor the end of the name block.
\end{sphinxadmonition}


\section{Import of example Vias}
\label{\detokenize{photonics/techfile:import-of-example-vias}}
Importing a .LEF will create the layerproperties. The layerproperties are the layer-purpose-pairs of KLayout. When using the lef import script built into
KLayout, it will automatically load example vias into a new layout. Unfortunately, the layers are not the correct layers from the technology files.
The layers can be edited by selecting a layer in the layers sub-window and then editing the layer via \sphinxmenuselection{Edit \(\rightarrow\) Layer \(\rightarrow\) Edit Layer Specification}.
Recommended place is in the \sphinxtitleref{\textasciitilde{}/.klayout/tech/libraries} or if using a package: \sphinxtitleref{\textasciitilde{}/.klayout/salt/\textless{}package-name\textgreater{}/tech/libraries}. These will automatically be loaded and are available as static cells for insert or in PCells.


\section{Layermap}
\label{\detokenize{photonics/techfile:layermap}}
The .layermap file is usually supplied by the foundry. This file can be used in the pcell\_lib\_ext to use layernames instead of layer numbers in the PCell Library.
It contains layername \textbar{} layernumber \textbar{} layerdatatype on each line for each layer. They have to be separated by white spaces. Afterwards, they can by used by the \sphinxtitleref{self.add\_layer(str varname, str layername)}
function during the \sphinxtitleref{\_\_init\_\_} of a new class of a PCell. Later the layer is accessible as \sphinxtitleref{self.varname}.

Recommended place is again in the tech folder.


\chapter{Code Documentation}
\label{\detokenize{modules:code-documentation}}\label{\detokenize{modules::doc}}

\section{drc Module}
\label{\detokenize{drc/drc:drc-module}}\label{\detokenize{drc/drc::doc}}

\subsection{Module contents}
\label{\detokenize{drc/drc:module-kppc.drc}}\label{\detokenize{drc/drc:module-contents}}\index{kppc.drc (module)@\spxentry{kppc.drc}\spxextra{module}}
This module uses the C++ submodule {\hyperref[\detokenize{drc/drc:slcleaner}]{\sphinxcrossref{\DUrole{std,std-ref}{slcleaner}}}}. It has to be compiled after installing the
extension.

To compile the module execute the setup script \sphinxcode{\sphinxupquote{scripts/compile.sh}}.
Or alternatively execute the \sphinxcode{\sphinxupquote{python/kppc/drc/slcleaner\_source/setup.py}} with the python3 executable
and copy/move the resulting \sphinxcode{\sphinxupquote{slcleaner.{[}...{]}.so}} library file ino the \sphinxcode{\sphinxupquote{python/drc/}} folder.

For further information consult the \sphinxhref{http://cython.org/}{Cython Documentation}%
\begin{footnote}[5]\sphinxAtStartFootnote
\sphinxnolinkurl{http://cython.org/}
%
\end{footnote}.

To execute the script open a console and execute the following commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+go}{cd \PYGZti{}/.klayout/salt/KLayoutPhotonicPCells/core/scripts}
\PYG{g+go}{sh compile.sh}
\end{sphinxVerbatim}

The bash script executes the following commands:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/bin/bash}

\PYG{c+c1}{\PYGZsh{}Script that compiles the C++ scanline algorithm with cython to a python module and copies it into the current folder}
\PYG{c+c1}{\PYGZsh{}If there is an \PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}.py in the folder the setup script will create subfolders, so avoid that}

\PYG{n+nb}{cd} \PYG{l+s+s2}{\PYGZdq{}}\PYG{k}{\PYGZdl{}(}dirname \PYG{l+s+s2}{\PYGZdq{}}\PYG{n+nv}{\PYGZdl{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{k}{)}\PYG{l+s+s2}{\PYGZdq{}}

sh ./clean
sh ./compile.sh
\end{sphinxVerbatim}
\index{clean() (in module kppc.drc)@\spxentry{clean()}\spxextra{in module kppc.drc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.clean}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{kppc.drc.}}\sphinxbfcode{\sphinxupquote{clean}}}{\emph{cell}, \emph{cleanrules}}{}
Clean a cell for width and space violations.
This function will clear the output layers of any shapes and insert a cleaned region.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cell}} (\sphinxstyleliteralemphasis{\sphinxupquote{pya.Cell}}) \textendash{} pointer to the cell that needs to be cleaned

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cleanrules}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#list}{\sphinxcode{\sphinxupquote{list}}}%
\begin{footnote}[6]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#list}
%
\end{footnote}) \textendash{} list with the layerpurposepairs, violationwidths and violationspaces in the form {[}{[}{[}layer,
purpose{]}, violationwidth, violationspace{]}, {[}{[}layer2, purpose2{]}, violationwidth2, violationspace2{]}, …{]}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{multiprocessing\_clean() (in module kppc.drc)@\spxentry{multiprocessing\_clean()}\spxextra{in module kppc.drc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.multiprocessing_clean}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{kppc.drc.}}\sphinxbfcode{\sphinxupquote{multiprocessing\_clean}}}{\emph{cell}, \emph{cleanrules}}{}
Clean a cell for width and space violations.
This function will clear the output layers of any shapes and insert a cleaned region.
Does the cleaning in a seperate Process started as a childprocess,
which will calculate in parallel with multiple threads.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cell}} (\sphinxstyleliteralemphasis{\sphinxupquote{pya.Cell}}) \textendash{} pointer to the cell that needs to be cleaned

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cleanrules}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#list}{\sphinxcode{\sphinxupquote{list}}}%
\begin{footnote}[7]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#list}
%
\end{footnote}) \textendash{} list with the layerpurposepairs, violationwidths and violationspaces in the form {[}{[}{[}layer,
purpose{]}, violationwidth, violationspace{]}, {[}{[}layer2, purpose2{]}, violationwidth2, violationspace2{]}, …{]}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subsection{Submodules}
\label{\detokenize{drc/drc:submodules}}

\subsubsection{kppc.drc.slcleaner module}
\label{\detokenize{drc/drc:kppc-drc-slcleaner-module}}\label{\detokenize{drc/drc:slcleaner}}
An interface to the DrcSl.cpp Class.
\index{kppc.drc.slcleaner.PyDrcSl (class in kppc.drc)@\spxentry{kppc.drc.slcleaner.PyDrcSl}\spxextra{class in kppc.drc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.kppc.drc.slcleaner.PyDrcSl}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{kppc.drc.slcleaner.}}\sphinxbfcode{\sphinxupquote{PyDrcSl}}}~

\begin{fulllineitems}
\pysigline{\sphinxbfcode{\sphinxupquote{def~add\_data(x1,~x2,~y1,~y2)}}}
Insert data into the scanline cleaner. The data is an edge that will be manhattanized and cleaned.

\begin{sphinxadmonition}{note}{Note:}
Edges should be added in such a way that the
outwards face is left in the direction of p1 to p2.
Klayout already does this nicely.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x1}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}%
\begin{footnote}[8]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} x position of p1 of the edge

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x2}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}%
\begin{footnote}[9]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} y position of p1 of the edge

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y1}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}%
\begin{footnote}[10]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} x position of p2 of the edge

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y2}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}%
\begin{footnote}[11]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} y position of p2 of the edge

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{clean() (kppc.drc.kppc.drc.slcleaner.PyDrcSl method)@\spxentry{clean()}\spxextra{kppc.drc.kppc.drc.slcleaner.PyDrcSl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.kppc.drc.slcleaner.PyDrcSl.clean}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clean}}}{\emph{x = 10}}{}
Clean data in the vector for space and width violations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} number of max tries

\end{description}\end{quote}

\end{fulllineitems}

\index{clean\_space() (kppc.drc.kppc.drc.slcleaner.PyDrcSl method)@\spxentry{clean\_space()}\spxextra{kppc.drc.kppc.drc.slcleaner.PyDrcSl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.kppc.drc.slcleaner.PyDrcSl.clean_space}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clean\_space}}}{}{}
Clean the current data for space violations.

\end{fulllineitems}

\index{clean\_width() (kppc.drc.kppc.drc.slcleaner.PyDrcSl method)@\spxentry{clean\_width()}\spxextra{kppc.drc.kppc.drc.slcleaner.PyDrcSl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.kppc.drc.slcleaner.PyDrcSl.clean_width}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clean\_width}}}{}{}
Clean the current data for width violations.

\end{fulllineitems}

\index{init\_list() (kppc.drc.kppc.drc.slcleaner.PyDrcSl method)@\spxentry{init\_list()}\spxextra{kppc.drc.kppc.drc.slcleaner.PyDrcSl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.kppc.drc.slcleaner.PyDrcSl.init_list}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{init\_list}}}{\emph{x1: int}, \emph{x2: int}, \emph{y1: int}, \emph{y2: int}, \emph{viospace: int}, \emph{viowidth: int}}{}
(Re-)Initialize the Cleaner. x1,2 and y1,2 define the bounding box of the cleaner.

\begin{sphinxadmonition}{warning}{Warning:}
If a corner or a complete edge is outside the bounding box and is added through the add\_data function, a Segmentation Fault will most likely occur and the module (including Klayout) crashes. Alternatively, it will just be confined to the bounding box and the rest will be cut off.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x1}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}%
\begin{footnote}[12]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} left bound of box

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x2}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}%
\begin{footnote}[13]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} right bound of box

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y1}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}%
\begin{footnote}[14]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} bottom bound of box

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y2}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}%
\begin{footnote}[15]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} top bound of box

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{viospace}} (\sphinxstyleliteralemphasis{\sphinxupquote{minimum space violation in database units}}) \textendash{} minimum space violation in database units

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{viowidth}} (\sphinxstyleliteralemphasis{\sphinxupquote{minimum width violation in database units}}) \textendash{} minimum width violation in database units

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_row() (kppc.drc.kppc.drc.slcleaner.PyDrcSl method)@\spxentry{get\_row()}\spxextra{kppc.drc.kppc.drc.slcleaner.PyDrcSl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.kppc.drc.slcleaner.PyDrcSl.get_row}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_row}}}{\emph{ind: int}}{}
Get the edge data back to python from the C++ object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ind}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}%
\begin{footnote}[16]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} index of the row to retrieve data from

\item[{Returns}] \leavevmode
numpy array of the edges

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_row\_types() (kppc.drc.kppc.drc.slcleaner.PyDrcSl method)@\spxentry{get\_row\_types()}\spxextra{kppc.drc.kppc.drc.slcleaner.PyDrcSl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.kppc.drc.slcleaner.PyDrcSl.get_row_types}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_row\_types}}}{\emph{ind: int}}{}
Get the type of edges in that row.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ind}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}%
\begin{footnote}[17]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} index of the row

\item[{Returns}] \leavevmode
numpy array of types of edges (0 for upwards facing edge, 1 for downwards)

\end{description}\end{quote}

\end{fulllineitems}

\index{polygons() (kppc.drc.kppc.drc.slcleaner.PyDrcSl method)@\spxentry{polygons()}\spxextra{kppc.drc.kppc.drc.slcleaner.PyDrcSl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.kppc.drc.slcleaner.PyDrcSl.polygons}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{polygons}}}{}{}
Returns list of crude polygons. The format is list of polygons, where a polygon is a list of tuples of (x,y)
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
polygons in the form {[}{[}(x1,y1),(x2,y2),…{]},…{]}

\item[{Return\_type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{printvector() (kppc.drc.kppc.drc.slcleaner.PyDrcSl method)@\spxentry{printvector()}\spxextra{kppc.drc.kppc.drc.slcleaner.PyDrcSl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.kppc.drc.slcleaner.PyDrcSl.printvector}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{printvector}}}{\emph{beg = -1}, \emph{end = -1}}{}
Print the data of rows/columns depending on current orientation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{beg}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}%
\begin{footnote}[18]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} beginning of the rows/columns that should be printed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{end}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}%
\begin{footnote}[19]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} ending of the rows/columns that should be printed

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{s() (kppc.drc.kppc.drc.slcleaner.PyDrcSl method)@\spxentry{s()}\spxextra{kppc.drc.kppc.drc.slcleaner.PyDrcSl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.kppc.drc.slcleaner.PyDrcSl.s}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{s}}}{}{}
This property can be used to get the array size of the cleaner.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Size of the array of vectors.

\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{int}%
\begin{footnote}[20]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}

\end{description}\end{quote}

\end{fulllineitems}

\index{sort() (kppc.drc.kppc.drc.slcleaner.PyDrcSl method)@\spxentry{sort()}\spxextra{kppc.drc.kppc.drc.slcleaner.PyDrcSl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.kppc.drc.slcleaner.PyDrcSl.sort}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sort}}}{}{}
Sort the data in ascending order. This will also delete invalid edges, i.e. touching / overlapping polygons will be merged.

\end{fulllineitems}

\index{switch\_dimensions() (kppc.drc.kppc.drc.slcleaner.PyDrcSl method)@\spxentry{switch\_dimensions()}\spxextra{kppc.drc.kppc.drc.slcleaner.PyDrcSl method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.kppc.drc.slcleaner.PyDrcSl.switch_dimensions}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{switch\_dimensions}}}{}{}
Switch the orientation of the data. From row oriented to column oriented and vice-versa.

\end{fulllineitems}


\end{fulllineitems}


This wrapper is used to expose the design rule cleaner class to the python PCells of KLayout.
The algorithm is pasted below. The algorithm uses a \sphinxhref{https://en.wikipedia.org/wiki/Scanline\_rendering}{Scanline Rendering Algorithm}%
\begin{footnote}[21]\sphinxAtStartFootnote
\sphinxnolinkurl{https://en.wikipedia.org/wiki/Scanline\_rendering}
%
\end{footnote}
to first convert the polygons from KLayout to manhattanized edges and then add them into an array representation
of the polygon edges.

Source Code: {\hyperref[\detokenize{source_code/drcsl_source:drcslsource}]{\sphinxcrossref{\DUrole{std,std-ref}{DrcSl Source}}}}


\subsection{Multiprocessing}
\label{\detokenize{drc/drc:multiprocessing}}
With version 0.1.0 multiprocessing was introduced. Multiprocessing allows to use all threads of the machine to process the DRC cleaning on all threads of the CPU in parallel. This can give a considerable speed boost if multiple layers are involved and the hardware supports it.


\subsubsection{kppc.drc.cleanermaster module}
\label{\detokenize{drc/drc:kppc-drc-cleanermaster-module}}\label{\detokenize{drc/drc:cm}}
Wrapper Class for CleanerMaster.cpp

This Class creates a managed shared memory space. Polygon data for cleaning are streamed into this memory space. A slave process (cleanermain, which is a little loop for CleanerSlave.cpp).


\paragraph{Python Class}
\label{\detokenize{drc/drc:python-class}}\index{PyCleanerMaster (class in kppc.drc)@\spxentry{PyCleanerMaster}\spxextra{class in kppc.drc}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.PyCleanerMaster}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{kppc.drc.}}\sphinxbfcode{\sphinxupquote{PyCleanerMaster}}}~\index{add\_edge() (kppc.drc.PyCleanerMaster method)@\spxentry{add\_edge()}\spxextra{kppc.drc.PyCleanerMaster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.PyCleanerMaster.add_edge}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_edge}}}{\emph{self}, \emph{x1 : int}, \emph{x2 : int}, \emph{y1 : int}, \emph{y2 : int}}{}
Add an edge to the cleaner.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x1}} \textendash{} first x coordinate

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x2}} \textendash{} second x coordinate

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y1}} \textendash{} first y coordinate

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y2}} \textendash{} second y coordinate

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{done() (kppc.drc.PyCleanerMaster method)@\spxentry{done()}\spxextra{kppc.drc.PyCleanerMaster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.PyCleanerMaster.done}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{done}}}{\emph{self}}{}
Indicates whether there is data still in the buffer from the last read or not.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
false if the buffer is empty and the data has been read by the slave.

\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{bool}%
\begin{footnote}[22]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#bool}
%
\end{footnote}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_layer() (kppc.drc.PyCleanerMaster method)@\spxentry{get\_layer()}\spxextra{kppc.drc.PyCleanerMaster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.PyCleanerMaster.get_layer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_layer}}}{\emph{self}}{}
Read the next processed layer in the memory space and returns it in per line style (x coordinates per line (y coordinate)). This is considerably slower than returning the polygons.

\end{fulllineitems}

\index{polygons() (kppc.drc.PyCleanerMaster method)@\spxentry{polygons()}\spxextra{kppc.drc.PyCleanerMaster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.PyCleanerMaster.polygons}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{polygons}}}{\emph{self}}{}
Reads the next processed layer in the memory and assembles the line style to polygons.

\end{fulllineitems}

\index{set\_box() (kppc.drc.PyCleanerMaster method)@\spxentry{set\_box()}\spxextra{kppc.drc.PyCleanerMaster method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:kppc.drc.PyCleanerMaster.set_box}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_box}}}{\emph{self}, \emph{layer : int}, \emph{datatype : int}, \emph{violation\_width : int}, \emph{violation\_space : int}, \emph{x1 : int}, \emph{x2 : int}, \emph{y1 : int}, \emph{y2 : int}}{}
Allocate enough space in the shared memory to stream the cell and its polygons in.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{layer}} \textendash{} layer number

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{datatype}} \textendash{} datatype number

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{viospace}} (\sphinxstyleliteralemphasis{\sphinxupquote{minimum space violation in database units}}) \textendash{} minimum space violation in database units

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{viowidth}} (\sphinxstyleliteralemphasis{\sphinxupquote{minimum width violation in database units}}) \textendash{} minimum width violation in database units

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x1}} \textendash{} left bound of box

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x2}} \textendash{} right bound of box

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y1}} \textendash{} bottom bound of box

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y2}} \textendash{} top bound of box

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\paragraph{C++ Class}
\label{\detokenize{drc/drc:c-class}}\index{CleanerMaster (C++ class)@\spxentry{CleanerMaster}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:_CPPv413CleanerMaster}}%
\pysigstartmultiline
\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CleanerMaster}}}%
\pysigstopmultiline~\index{CleanerMaster::CleanerMaster (C++ function)@\spxentry{CleanerMaster::CleanerMaster}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:_CPPv4N13CleanerMaster13CleanerMasterEi}}%
\pysigstartmultiline
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{CleanerMaster}}}{int \sphinxstyleemphasis{nlayers}}{}%
\pysigstopmultiline
Creates the shared memory space and resizes the vectors for nlayers

\end{fulllineitems}

\index{CleanerMaster::set\_box (C++ function)@\spxentry{CleanerMaster::set\_box}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:_CPPv4N13CleanerMaster7set_boxEiiiiiiii}}%
\pysigstartmultiline
\pysiglinewithargsret{void \sphinxbfcode{\sphinxupquote{set\_box}}}{int \sphinxstyleemphasis{layer}, int \sphinxstyleemphasis{datatype}, int \sphinxstyleemphasis{violation\_width}, int \sphinxstyleemphasis{violation\_space}, int \sphinxstyleemphasis{x1}, int \sphinxstyleemphasis{x2}, int \sphinxstyleemphasis{y1}, int \sphinxstyleemphasis{y2}}{}%
\pysigstopmultiline
Allocate enough space in the shared memory to stream the cell and its polygons in.

\end{fulllineitems}

\index{CleanerMaster::add\_edge (C++ function)@\spxentry{CleanerMaster::add\_edge}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:_CPPv4N13CleanerMaster8add_edgeEiiii}}%
\pysigstartmultiline
\pysiglinewithargsret{void \sphinxbfcode{\sphinxupquote{add\_edge}}}{int \sphinxstyleemphasis{x1}, int \sphinxstyleemphasis{x2}, int \sphinxstyleemphasis{y1}, int \sphinxstyleemphasis{y2}}{}%
\pysigstopmultiline
Add an edge to the cleaner.

\end{fulllineitems}

\index{CleanerMaster::done (C++ function)@\spxentry{CleanerMaster::done}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:_CPPv4N13CleanerMaster4doneEv}}%
\pysigstartmultiline
\pysiglinewithargsret{bool \sphinxbfcode{\sphinxupquote{done}}}{}{}%
\pysigstopmultiline
Indicates whether there is data still in the buffer from the last read or not.

\end{fulllineitems}

\index{CleanerMaster::get\_layer (C++ function)@\spxentry{CleanerMaster::get\_layer}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:_CPPv4N13CleanerMaster9get_layerEv}}%
\pysigstartmultiline
\pysiglinewithargsret{std::vector\textless{}std::vector\textless{}int\textgreater{}\textgreater{} \sphinxbfcode{\sphinxupquote{get\_layer}}}{}{}%
\pysigstopmultiline
Read the next processed layer in the memory space and returns it in per line style (x coordinates per line (y coordinate)).

\end{fulllineitems}

\index{CleanerMaster::get\_polygons (C++ function)@\spxentry{CleanerMaster::get\_polygons}\spxextra{C++ function}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:_CPPv4N13CleanerMaster12get_polygonsEv}}%
\pysigstartmultiline
\pysiglinewithargsret{std::vector\textless{}std::vector\textless{}std::pair\textless{}int, int\textgreater{}\textgreater{}\textgreater{} \sphinxbfcode{\sphinxupquote{get\_polygons}}}{}{}%
\pysigstopmultiline
Reads the next processed layer in the memory and assembles the line style to polygons.

\end{fulllineitems}


\end{fulllineitems}


C++ Source Code: {\hyperref[\detokenize{source_code/cleanermaster_source:cmsource}]{\sphinxcrossref{\DUrole{std,std-ref}{CleanerMaster Source}}}}


\subsubsection{CleanerMain}
\label{\detokenize{drc/drc:cleanermain}}\label{\detokenize{drc/drc:cmain}}
C++ documentation of the cleanermain. This program is a simple program with a loop that processes any layers added to the shared memory. If the process receives \sphinxtitleref{SIGUSER1}, it joins the threads and terminates afterwards.

Source: {\hyperref[\detokenize{source_code/cleanermain_source:cmainsource}]{\sphinxcrossref{\DUrole{std,std-ref}{CleanerMain Source}}}}


\subsubsection{CleanerSlave}
\label{\detokenize{drc/drc:cleanerslave}}\label{\detokenize{drc/drc:cs}}

\paragraph{C++ Class}
\label{\detokenize{drc/drc:id1}}\index{CleanerSlave (C++ class)@\spxentry{CleanerSlave}\spxextra{C++ class}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:_CPPv412CleanerSlave}}%
\pysigstartmultiline
\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{CleanerSlave}}}%
\pysigstopmultiline~\index{CleanerSlave::CleanerSlave (C++ member)@\spxentry{CleanerSlave::CleanerSlave}\spxextra{C++ member}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:_CPPv4N12CleanerSlave12CleanerSlaveE}}%
\pysigstartmultiline
\pysiglinewithargsret{void \sphinxbfcode{\sphinxupquote{CleanerSlave}}}{}{}%
\pysigstopmultiline
Constructor of the Class
The constructor opens the shared memory and initializes the allocators for the shared memory. Initializes a boost thread\_pool with as many threads as the CPU supports (one per core).

\end{fulllineitems}

\index{CleanerSlave::clean (C++ member)@\spxentry{CleanerSlave::clean}\spxextra{C++ member}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:_CPPv4N12CleanerSlave5cleanE}}%
\pysigstartmultiline
\pysiglinewithargsret{void \sphinxbfcode{\sphinxupquote{clean}}}{}{}%
\pysigstopmultiline
Checks if the shared memory has a cell layer added. If there is a layer to process, move the data to shared memory and schedule it for processing by the thread\_pool.

\end{fulllineitems}

\index{CleanerSlave::join\_threads (C++ member)@\spxentry{CleanerSlave::join\_threads}\spxextra{C++ member}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{drc/drc:_CPPv4N12CleanerSlave12join_threadsE}}%
\pysigstartmultiline
\pysiglinewithargsret{void \sphinxbfcode{\sphinxupquote{join\_threads}}}{}{}%
\pysigstopmultiline
Wait for the thread\_pool to finish all jobs and return

\end{fulllineitems}


\end{fulllineitems}


Source Code: {\hyperref[\detokenize{source_code/cleanerslave_source:cssource}]{\sphinxcrossref{\DUrole{std,std-ref}{CleanerSlave Source}}}}


\section{photonics Module}
\label{\detokenize{photonics/photonics:photonics-module}}\label{\detokenize{photonics/photonics::doc}}
This package is a library extension for KLayout to provide functionalities for photonic structures.

\begin{sphinxadmonition}{warning}{Warning:}
KLayout does not check if a loaded module has changed during runtime and thus does not reread/recompile it.
This means you either must manually reload the library if you want to do it during runtime. Generally, it is easier and
safer to close and reopen KLayout.

If this extension is modified (or any file in a \sphinxcode{\sphinxupquote{/python}} directory), don’t forget to either reload the module or
reopen KLayout.

\begin{sphinxadmonition}{note}{Note:}
To reload a module during runtime use the following commands in the KLayout python console (not guaranteed to work in all cases):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{importlib} \PYG{k}{import} \PYG{n}{reload}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{reload}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{module}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}
\end{sphinxadmonition}
\end{sphinxadmonition}


\subsection{Module contents}
\label{\detokenize{photonics/photonics:module-kppc.photonics}}\label{\detokenize{photonics/photonics:module-contents}}\index{kppc.photonics (module)@\spxentry{kppc.photonics}\spxextra{module}}
Photonic PCell-Extension Module

\begin{sphinxadmonition}{warning}{Warning:}
Before using this module for the first time, make sure the \sphinxtitleref{kppc.drc.slcleaner} submodule is compiled and importable, as this  module
relies on the drc package for DR-Cleaning. See \sphinxcode{\sphinxupquote{drc}} for further details.
\end{sphinxadmonition}

A Module which provides extensions for standard KLyaout-PCells. This extension mainly provides functionalities for
photonics. One main feature of photonics are so-called ports. These define a position and a direction on a Cell.
They indicate where multiple Cells/Devices should interact with each other. For example, one can connect a waveguide
with a linear taper. This module provides the classes and functions for this functionality. Additionally, this module
provides a lot of convenience functions for interactions with the KLayout-API.

The main functionality for this module is in the class {\hyperref[\detokenize{photonics/photonics:kppc.photonics.PhotDevice}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{PhotDevice}}}}}.

\begin{sphinxadmonition}{warning}{Warning:}
When using this module to extend a PCell-Library any PCell class has to assign valid values to the
parameters \sphinxcode{\sphinxupquote{layermap}} , \sphinxcode{\sphinxupquote{dataprep\_config}} , \sphinxcode{\sphinxupquote{clean\_rules}} . These are accessed by {\hyperref[\detokenize{photonics/photonics:kppc.photonics.PhotDevice}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{PhotDevice}}}}}. If they
aren’t declared, a runtime error will occur.
\end{sphinxadmonition}
\index{InstanceHolder (class in kppc.photonics)@\spxentry{InstanceHolder}\spxextra{class in kppc.photonics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.InstanceHolder}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{kppc.photonics.}}\sphinxbfcode{\sphinxupquote{InstanceHolder}}}{\emph{cell\_name}, \emph{lib}, \emph{pcell\_decl}, \emph{params=None}, \emph{params\_mod=None}, \emph{id=0}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/functions.html\#object}{\sphinxcode{\sphinxupquote{object}}}%
\begin{footnote}[23]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#object}
%
\end{footnote}

Class to keep track and hold the information of a pcell instance. The information will be processed to a PCell in
{\hyperref[\detokenize{photonics/photonics:kppc.photonics.PhotDevice.produce_impl}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{produce\_impl()}}}}}
\index{move() (kppc.photonics.InstanceHolder method)@\spxentry{move()}\spxextra{kppc.photonics.InstanceHolder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.InstanceHolder.move}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{move}}}{\emph{x=0}, \emph{y=0}, \emph{rot=0}, \emph{mirrx=False}, \emph{mag=1}}{}
Moves an instance. Units of microns relative to origin.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}%
\begin{footnote}[24]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#float}
%
\end{footnote}) \textendash{} x position where to move

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}%
\begin{footnote}[25]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#float}
%
\end{footnote}) \textendash{} y position where to move

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rot}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}%
\begin{footnote}[26]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} Rotation of the object in degrees

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mirrx}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}%
\begin{footnote}[27]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#bool}
%
\end{footnote}) \textendash{} Mirror at x-axis if True

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mag}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}%
\begin{footnote}[28]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#float}
%
\end{footnote}) \textendash{} Magnification of the Cell. This feature is not tested well.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{port() (kppc.photonics.InstanceHolder method)@\spxentry{port()}\spxextra{kppc.photonics.InstanceHolder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.InstanceHolder.port}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{port}}}{\emph{port}}{}
Returns a reference to itself and the port number. No checks are made whether this port is valid or not!
Available ports can be seen if such an object is instantiated.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{port}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxcode{\sphinxupquote{int}}}%
\begin{footnote}[29]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} index of the port

\item[{Returns}] \leavevmode
self, port

\end{description}\end{quote}

\end{fulllineitems}

\index{port\_to\_port() (kppc.photonics.InstanceHolder method)@\spxentry{port\_to\_port()}\spxextra{kppc.photonics.InstanceHolder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.InstanceHolder.port_to_port}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{port\_to\_port}}}{\emph{port}, \emph{inst\_holder}}{}
Attach one of this instance’s ports to another instance’s port.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{port}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxcode{\sphinxupquote{int}}}%
\begin{footnote}[30]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} port of this instance

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{inst\_holder}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#tuple}{\sphinxcode{\sphinxupquote{tuple}}}%
\begin{footnote}[31]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#tuple}
%
\end{footnote}) \textendash{} Tuple of the the reference to the other instance and the port to connect to.
This is a tuple returned from \textless{}InstanceHolder object\textgreater{}.port(\textless{}portnumber\textgreater{}).

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PhotDevice (class in kppc.photonics)@\spxentry{PhotDevice}\spxextra{class in kppc.photonics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{kppc.photonics.}}\sphinxbfcode{\sphinxupquote{PhotDevice}}}
Bases: \sphinxcode{\sphinxupquote{pya.PCellDeclarationHelper}}

Wrapper for calls to the Klayout API.
\begin{quote}\begin{description}
\item[{Variables}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{layermap}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{\sphinxstyleliteralemphasis{\sphinxupquote{dict}}}%
\begin{footnote}[32]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#dict}
%
\end{footnote}) \textendash{} The layermap dictionary. This value has to be written by a child class. If undefined this
class won’t work and crash.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dataprep\_config}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}%
\begin{footnote}[33]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#str}
%
\end{footnote}) \textendash{} String with the path to the file containing the dataprep instructions.
If left empty, dataprep will do nothing.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{clean\_rules}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#list}{\sphinxstyleliteralemphasis{\sphinxupquote{list}}}%
\begin{footnote}[34]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#list}
%
\end{footnote}) \textendash{} String with the path to the file containing the DR-Cleaning rules.
If left empty, DR-Cleaning will do nothing. If the cells are built similar to the FreePDK45-SampleCells example,
DR-Cleaning will not work without dataprep, or will be without any effect.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{keep}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}%
\begin{footnote}[35]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#bool}
%
\end{footnote}) \textendash{} Parameter created during \sphinxcode{\sphinxupquote{\_\_init\_\_()}} via pya.DeclarationHelper. If set to True in the PCell,
all child-cells will be preserved at the end. If set to False only the Dataprep Sub-Cell will be preserved.

\item {} 
{\hyperref[\detokenize{photonics/photonics:module-kppc.photonics.dataprep}]{\sphinxcrossref{\sphinxstyleliteralstrong{\sphinxupquote{dataprep}}}}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}%
\begin{footnote}[36]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#bool}
%
\end{footnote}) \textendash{} If this flag is set, {\hyperref[\detokenize{photonics/photonics:kppc.photonics.dataprep.dataprep}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{kppc.photonics.dataprep.dataprep()}}}}} will be performed on the cell. The variable
\sphinxcode{\sphinxupquote{dataprep\_config}} holds the path to the instructions for dataprep.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{clean}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}%
\begin{footnote}[37]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#bool}
%
\end{footnote}) \textendash{} If this flag is set, {\hyperref[\detokenize{drc/drc:kppc.drc.clean}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{kppc.drc.clean()}}}}} will be performed on the cell. Rules for the DR-Cleaning
are pulled from \sphinxcode{\sphinxupquote{clean\_rules}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{top}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxstyleliteralemphasis{\sphinxupquote{bool}}}%
\begin{footnote}[38]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#bool}
%
\end{footnote}) \textendash{} Hidden parameter that indicates whether this cell is a top\_cell. Default is yes. When an instance is
added through {\hyperref[\detokenize{photonics/photonics:kppc.photonics.PhotDevice.add_pcell_variant}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add\_pcell\_variant()}}}}} these cells will not be set to top\_cells as they are instantiated from
another cell.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{only\_top\_ports}} \textendash{} GUI parameter. If set to true, only ports of the top most hierarchy level (top\_cell) will be
annotated by text.

\end{itemize}

\end{description}\end{quote}
\index{add\_layer() (kppc.photonics.PhotDevice method)@\spxentry{add\_layer()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.add_layer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_layer}}}{\emph{var\_name}, \emph{name=''}, \emph{layer=0}, \emph{datatype=0}, \emph{ld=()}, \emph{field\_name=''}, \emph{hidden=False}}{}
Add a layer to the layer list of the pcell by name.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{var\_name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxcode{\sphinxupquote{str}}}%
\begin{footnote}[39]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#str}
%
\end{footnote}) \textendash{} name of the variable

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxcode{\sphinxupquote{str}}}%
\begin{footnote}[40]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#str}
%
\end{footnote}) \textendash{} name in the pcell window

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{layer}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxcode{\sphinxupquote{int}}}%
\begin{footnote}[41]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} layernumber

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{datatype}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxcode{\sphinxupquote{int}}}%
\begin{footnote}[42]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} layerdatatype

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{field\_name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxcode{\sphinxupquote{str}}}%
\begin{footnote}[43]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#str}
%
\end{footnote}) \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hidden}} \textendash{} hide in the GUI

\end{itemize}

\item[{Examples}] \leavevmode
self.add\_layer(‘lpp’,’rx1phot.drawing’)

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_params() (kppc.photonics.PhotDevice method)@\spxentry{add\_params()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.add_params}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_params}}}{\emph{params}}{}
Create the PCell conform dictionary from a parameter list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{\sphinxcode{\sphinxupquote{dict}}}%
\begin{footnote}[44]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#dict}
%
\end{footnote}) \textendash{} Dictionary of parameters

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_pcell\_variant() (kppc.photonics.PhotDevice method)@\spxentry{add\_pcell\_variant()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.add_pcell_variant}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_pcell\_variant}}}{\emph{params}, \emph{number=1}}{}
Add variants of PCells. Creates a list of InstanceHolders and modifies their parameters accordingly.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{\sphinxcode{\sphinxupquote{dict}}}%
\begin{footnote}[45]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#dict}
%
\end{footnote}) \textendash{} parameter list from which to create pcells

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{number}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxcode{\sphinxupquote{int}}}%
\begin{footnote}[46]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} Number of instances to create

\end{itemize}

\item[{Returns}] \leavevmode
list of {\hyperref[\detokenize{photonics/photonics:kppc.photonics.InstanceHolder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{kppc.photonics.InstanceHolder}}}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_pcells() (kppc.photonics.PhotDevice method)@\spxentry{add\_pcells()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.add_pcells}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_pcells}}}{\emph{instance\_list}}{}
Creates list of instances of PCells. These are the effective Klayout cell instances.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{instance\_list}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#list}{\sphinxcode{\sphinxupquote{list}}}%
\begin{footnote}[47]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#list}
%
\end{footnote}) \textendash{} list of {\hyperref[\detokenize{photonics/photonics:kppc.photonics.InstanceHolder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{kppc.photonics.InstanceHolder}}}}}

\item[{Returns}] \leavevmode
list of instantiated pya.CellInstArray

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_ports() (kppc.photonics.PhotDevice method)@\spxentry{calculate\_ports()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.calculate_ports}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_ports}}}{\emph{instances}}{}
Calculates port locations in the cell layout. This is to propagate the port locations upwards
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{instances}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#list}{\sphinxcode{\sphinxupquote{list}}}%
\begin{footnote}[48]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#list}
%
\end{footnote}) \textendash{} list containing {\hyperref[\detokenize{photonics/photonics:kppc.photonics.InstanceHolder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{kppc.photonics.InstanceHolder}}}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{clear\_ports() (kppc.photonics.PhotDevice method)@\spxentry{clear\_ports()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.clear_ports}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{clear\_ports}}}{}{}
Clears self.portlist and by that delete all ports. This is used when updating the Ports

\end{fulllineitems}

\index{coerce\_parameters\_impl() (kppc.photonics.PhotDevice method)@\spxentry{coerce\_parameters\_impl()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.coerce_parameters_impl}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{coerce\_parameters\_impl}}}{}{}
Method called by Klayout to update a PCell. For photonic PCells the ports are updated/calculated in the
parameter of the PCell. And desired movement transformations are performed.

Because the calculated ports of our own PCell are used by parent cells and are needed before
\sphinxtitleref{\textasciitilde{}produce\_impl}, we must calculate them twice. First to calculate where our own ports are and then again to
instantiate the child cells. This is unfortunate but not a big problem, since dataprep and DR-cleaning take
the majority of computation time.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{connect\_port() (kppc.photonics.PhotDevice method)@\spxentry{connect\_port()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.connect_port}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{connect\_port}}}{\emph{pos1}, \emph{portlist1}, \emph{port1}, \emph{pos2}, \emph{portlist2}, \emph{port2}}{}
Connect ports of two instances. The second instance will be transformed to attach to the first instance.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pos1}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxcode{\sphinxupquote{int}}}%
\begin{footnote}[49]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} index of instance1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{portlist1}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxcode{\sphinxupquote{str}}}%
\begin{footnote}[50]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#str}
%
\end{footnote}) \textendash{} portlist of instance1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{port1}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxcode{\sphinxupquote{int}}}%
\begin{footnote}[51]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} port number of instance1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pos2}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxcode{\sphinxupquote{int}}}%
\begin{footnote}[52]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} index of instance2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{portlist2}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxcode{\sphinxupquote{str}}}%
\begin{footnote}[53]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#str}
%
\end{footnote}) \textendash{} portlist of instance2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{port2}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxcode{\sphinxupquote{int}}}%
\begin{footnote}[54]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} port number of instance2

\end{itemize}

\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxcode{\sphinxupquote{int}}}%
\begin{footnote}[55]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}

\end{description}\end{quote}

\end{fulllineitems}

\index{connect\_port\_to\_port() (kppc.photonics.PhotDevice method)@\spxentry{connect\_port\_to\_port()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.connect_port_to_port}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{connect\_port\_to\_port}}}{\emph{port1}, \emph{port2}}{}
Connect Ports from two InstanceHolder instances.

Connect two \sphinxtitleref{InstanceHolders} together. Attach \textless{}InstanceHolder instance1\textgreater{}.port(\textless{}port1\textgreater{}) to \textless{}InstanceHolder instance2\textgreater{}.port(\textless{}port2\textgreater{}).
This will apply a transformation to Instance2. There can only be either a transformation through connect\_port\_to\_port or through InstanceHolder.move
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{port1}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#tuple}{\sphinxcode{\sphinxupquote{tuple}}}%
\begin{footnote}[56]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#tuple}
%
\end{footnote}) \textendash{} \textless{}InstanceHolder instance1\textgreater{}.port(\textless{}port1\textgreater{})

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{port2}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#tuple}{\sphinxcode{\sphinxupquote{tuple}}}%
\begin{footnote}[57]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#tuple}
%
\end{footnote}) \textendash{} \textless{}InstanceHolder instance2\textgreater{}.port(\textless{}port2\textgreater{})

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_param\_inst() (kppc.photonics.PhotDevice method)@\spxentry{create\_param\_inst()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.create_param_inst}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_param\_inst}}}{}{}
To be overwritten by the effective PCell
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Iterable with the declarations of the child PCells.

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_path() (kppc.photonics.PhotDevice method)@\spxentry{create\_path()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.create_path}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_path}}}{\emph{points}, \emph{width}, \emph{layer}}{}
Creates a pya.Path object and inserts it into the Library-PCell.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#list}{\sphinxcode{\sphinxupquote{list}}}%
\begin{footnote}[58]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#list}
%
\end{footnote}) \textendash{} The points describing the path {[}{[}x1,y1{]},{[}x2,y2{]},…{]} in microns

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{width}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxcode{\sphinxupquote{float}}}%
\begin{footnote}[59]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#float}
%
\end{footnote}) \textendash{} Path width

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{layer}} (\sphinxstyleliteralemphasis{\sphinxupquote{pya.LayerInfo}}) \textendash{} layer on which the path should be made

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_polygon() (kppc.photonics.PhotDevice method)@\spxentry{create\_polygon()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.create_polygon}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_polygon}}}{\emph{points}, \emph{layer}}{}
Creates a Polygon and adjusts from microns to database units. Format: {[}{[}x1,y1{]},{[}x2,y2{]},…{]} in microns
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#list}{\sphinxcode{\sphinxupquote{list}}}%
\begin{footnote}[60]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#list}
%
\end{footnote}) \textendash{} Points defining the corners of the polygon.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{layer}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxcode{\sphinxupquote{int}}}%
\begin{footnote}[61]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} layer\_index of the target layer

\end{itemize}

\item[{Returns}] \leavevmode
reference to polygon object

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_port() (kppc.photonics.PhotDevice method)@\spxentry{create\_port()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.create_port}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_port}}}{\emph{x}, \emph{y}, \emph{rot=0}, \emph{length=0}}{}
Creates a Port at the specified coordinates.

This function will be used when a port is created through the PortCreation tuple.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxcode{\sphinxupquote{float}}}%
\begin{footnote}[62]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#float}
%
\end{footnote}) \textendash{} x Coordinate in microns

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxcode{\sphinxupquote{float}}}%
\begin{footnote}[63]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#float}
%
\end{footnote}) \textendash{} y Coordinate in microns

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rot}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxcode{\sphinxupquote{int}}}%
\begin{footnote}[64]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} Rotation in degrees

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{length}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxcode{\sphinxupquote{int}}}%
\begin{footnote}[65]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} length of the port in microns

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{decl() (kppc.photonics.PhotDevice method)@\spxentry{decl()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.decl}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{decl}}}{\emph{libname}, \emph{cellname}}{}
Get pya.PCellDeclaration of a cell in a library
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{libname}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxcode{\sphinxupquote{str}}}%
\begin{footnote}[66]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#str}
%
\end{footnote}) \textendash{} Name of the library

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cellname}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxcode{\sphinxupquote{str}}}%
\begin{footnote}[67]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#str}
%
\end{footnote}) \textendash{} Name of the cell

\end{itemize}

\item[{Returns}] \leavevmode
pya.PCellDeclaration reference of PCell

\end{description}\end{quote}

\end{fulllineitems}

\index{flip\_shape\_xaxis() (kppc.photonics.PhotDevice method)@\spxentry{flip\_shape\_xaxis()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.flip_shape_xaxis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{flip\_shape\_xaxis}}}{\emph{shape}}{}
Flip a polygon (or any shape) at the x-axis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{shape}} (\sphinxstyleliteralemphasis{\sphinxupquote{pya.Shape}}) \textendash{} pya.Shape object (e.g. through photonicpcell.create\_polygon obtained)

\end{description}\end{quote}

\end{fulllineitems}

\index{flip\_shape\_yaxis() (kppc.photonics.PhotDevice method)@\spxentry{flip\_shape\_yaxis()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.flip_shape_yaxis}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{flip\_shape\_yaxis}}}{\emph{shape}}{}
Flip a polygon (or any shape) at the y-axis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{shape}} (\sphinxstyleliteralemphasis{\sphinxupquote{pya.Shape}}) \textendash{} pya.Shape object (e.g. through photonicpcell.create\_polygon obtained)

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_layer() (kppc.photonics.PhotDevice method)@\spxentry{get\_layer()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.get_layer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_layer}}}{\emph{name}, \emph{purpose=''}}{}
Creates LayerInfo object

Creates a pya.LayerInfo object to find layer indexes in the current layout.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxcode{\sphinxupquote{str}}}%
\begin{footnote}[68]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#str}
%
\end{footnote}) \textendash{} name of the layer

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{purpose}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxcode{\sphinxupquote{str}}}%
\begin{footnote}[69]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#str}
%
\end{footnote}) \textendash{} if not empty then layer and purpose are separate

\end{itemize}

\item[{Returns}] \leavevmode
pya.LayerInfo about the layer

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_transformations() (kppc.photonics.PhotDevice method)@\spxentry{get\_transformations()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.get_transformations}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_transformations}}}{}{}
Convert transformation strings back to pya.ICplxTrans objects
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
list of pya.ICplxTrans objects

\end{description}\end{quote}

\end{fulllineitems}

\index{insert\_shape() (kppc.photonics.PhotDevice method)@\spxentry{insert\_shape()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.insert_shape}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{insert\_shape}}}{\emph{shape}, \emph{layer}}{}
Any other Klayout shape can be added to the PCell through this function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{shape}} (\sphinxstyleliteralemphasis{\sphinxupquote{pya.Shape}}) \textendash{} pya.Shape object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{layer}} (\sphinxstyleliteralemphasis{\sphinxupquote{pya.LayerInfo}}) \textendash{} layer where to write to

\end{itemize}

\item[{Returns}] \leavevmode
reference to shape

\end{description}\end{quote}

\end{fulllineitems}

\index{move\_instance() (kppc.photonics.PhotDevice method)@\spxentry{move\_instance()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.move_instance}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{move\_instance}}}{\emph{ind}, \emph{trans}, \emph{mirror=False}}{}
Moves an InstanceHolder object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ind}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxcode{\sphinxupquote{int}}}%
\begin{footnote}[70]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} id of the InstanceHolder

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{trans}} (\sphinxstyleliteralemphasis{\sphinxupquote{pya.ICplxTrans}}) \textendash{} list of transformations

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mirror}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#bool}{\sphinxcode{\sphinxupquote{bool}}}%
\begin{footnote}[71]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#bool}
%
\end{footnote}) \textendash{} bool whether to mirror the object

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{produce\_impl() (kppc.photonics.PhotDevice method)@\spxentry{produce\_impl()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.produce_impl}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{produce\_impl}}}{}{}
Create the effective Klayout shapes. For this all the InstanceHolders are cycled through and all the child
instances are created. Furthermore, if desired, dataprep is performed, which copies and sizes the shapes as
desired. Dataprep will only create shapes on the topmost cell. Finally, if desired DR-cleaning is performed and
in the process the shapes will be manhattanized.

\end{fulllineitems}

\index{set\_transformation() (kppc.photonics.PhotDevice method)@\spxentry{set\_transformation()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.set_transformation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_transformation}}}{\emph{ind}, \emph{trans}}{}
Transforms child cells to the intended position, defined either by connected ports or by manual
positioning.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ind}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxcode{\sphinxupquote{int}}}%
\begin{footnote}[72]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} index of the child cell

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{trans}} (\sphinxstyleliteralemphasis{\sphinxupquote{pya.ICplxTrans}}) \textendash{} Transformation object with which to transform the child cell

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{shapes() (kppc.photonics.PhotDevice method)@\spxentry{shapes()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.shapes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{shapes}}}{}{}
To be overwritten by effective PCell if shapes should be desired.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/3/library/constants.html\#None}{None}%
\begin{footnote}[73]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/constants.html\#None}
%
\end{footnote}

\end{description}\end{quote}

\end{fulllineitems}

\index{update\_parameter\_list() (kppc.photonics.PhotDevice method)@\spxentry{update\_parameter\_list()}\spxextra{kppc.photonics.PhotDevice method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PhotDevice.update_parameter_list}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{update\_parameter\_list}}}{\emph{params}, \emph{decl}}{}
Coerces parameter list. This is necessary to calculate port locations and update parameters in general.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{\sphinxcode{\sphinxupquote{dict}}}%
\begin{footnote}[74]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#dict}
%
\end{footnote}) \textendash{} dict of parameters

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{decl}} (\sphinxstyleliteralemphasis{\sphinxupquote{pya.PCellDeclaration}}) \textendash{} pya.PCellDeclaration reference

\end{itemize}

\item[{Returns}] \leavevmode
list of updated parameters

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PortCreation (class in kppc.photonics)@\spxentry{PortCreation}\spxextra{class in kppc.photonics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.PortCreation}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{kppc.photonics.}}\sphinxbfcode{\sphinxupquote{PortCreation}}}{\emph{x}, \emph{y}, \emph{rot}, \emph{length}}{}
Bases: \sphinxhref{https://docs.python.org/3/library/functions.html\#object}{\sphinxcode{\sphinxupquote{object}}}%
\begin{footnote}[75]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#object}
%
\end{footnote}

Custom Class similar to a namedtuple

This will hold informations for creating ports.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}%
\begin{footnote}[76]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} x Coordinate {[}microns{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}%
\begin{footnote}[77]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#int}
%
\end{footnote}) \textendash{} y Coordinate {[}microns{]}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rot}} \textendash{} Rotation in degrees

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{length}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#float}{\sphinxstyleliteralemphasis{\sphinxupquote{float}}}%
\begin{footnote}[78]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/functions.html\#float}
%
\end{footnote}) \textendash{} Port length {[}microns{]}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{is\_named\_tuple\_instance() (in module kppc.photonics)@\spxentry{is\_named\_tuple\_instance()}\spxextra{in module kppc.photonics}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.is_named_tuple_instance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{kppc.photonics.}}\sphinxbfcode{\sphinxupquote{is\_named\_tuple\_instance}}}{\emph{x}}{}
Test if something is a named tuple
This allows to test if \sphinxtitleref{x} is a port (PortCreation object) or just a list of instance descriptions

\end{fulllineitems}



\subsection{Submodules}
\label{\detokenize{photonics/photonics:submodules}}

\subsubsection{photonics.dataprep module}
\label{\detokenize{photonics/photonics:module-kppc.photonics.dataprep}}\label{\detokenize{photonics/photonics:photonics-dataprep-module}}\index{kppc.photonics.dataprep (module)@\spxentry{kppc.photonics.dataprep}\spxextra{module}}\index{add() (in module kppc.photonics.dataprep)@\spxentry{add()}\spxextra{in module kppc.photonics.dataprep}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.dataprep.add}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{kppc.photonics.dataprep.}}\sphinxbfcode{\sphinxupquote{add}}}{\emph{layout}, \emph{cell}, \emph{slayers}, \emph{dlayers}, \emph{ex\_amount}, \emph{layers}, \emph{out\_cell=None}}{}
Combines all slayers’ shapes into a region and merges this region with each of dlayers’ regions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{layout}} \textendash{} the layout on which the cells are located

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cell}} \textendash{} the cell from which to copy the layers (source shapes)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{slayers}} \textendash{} the layers to copy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dlayers}} \textendash{} the layers where to copy to

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ex\_amount}} \textendash{} the amount added around the source shapes

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{layers}} \textendash{} the layermapping

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{out\_cell}} \textendash{} the cell where to put the shapes. If not specified, the input cell will be used.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{dataprep() (in module kppc.photonics.dataprep)@\spxentry{dataprep()}\spxextra{in module kppc.photonics.dataprep}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.dataprep.dataprep}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{kppc.photonics.dataprep.}}\sphinxbfcode{\sphinxupquote{dataprep}}}{\emph{in\_cell}, \emph{layout}, \emph{out\_cell=None}, \emph{config=None}, \emph{layers\_org=None}}{}
Dataprep that creates excludes layers etc. with boolean operation on input layers that will be added/substracted to outputlayers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{in\_cell}} \textendash{} the cell from which to take shapes

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{layout}} \textendash{} the layout on which we perform the operations (most likely self.layout)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{out\_cell}} \textendash{} the output cell. if not specified take the input cell

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{config}} \textendash{} the config file. This file specifies the boolean operations (self.dataprepconfig)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{layers\_org}} \textendash{} the original layermap we use (most likely self.layermap)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{file\_len() (in module kppc.photonics.dataprep)@\spxentry{file\_len()}\spxextra{in module kppc.photonics.dataprep}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.dataprep.file_len}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{kppc.photonics.dataprep.}}\sphinxbfcode{\sphinxupquote{file\_len}}}{\emph{fname}}{}
Returns the number of lines in the file fname

\end{fulllineitems}

\index{sub() (in module kppc.photonics.dataprep)@\spxentry{sub()}\spxextra{in module kppc.photonics.dataprep}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.dataprep.sub}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{kppc.photonics.dataprep.}}\sphinxbfcode{\sphinxupquote{sub}}}{\emph{layout}, \emph{cell}, \emph{slayers}, \emph{dlayers}, \emph{ex\_amount}, \emph{layers}, \emph{out\_cell=None}}{}
Analogous to {\hyperref[\detokenize{photonics/photonics:kppc.photonics.dataprep.add}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add()}}}}}

Instead of perfoming a combination with the destination layers, this function will substract the input region.

\end{fulllineitems}



\subsubsection{photonics.layermaps module}
\label{\detokenize{photonics/photonics:module-kppc.photonics.layermaps}}\label{\detokenize{photonics/photonics:photonics-layermaps-module}}\index{kppc.photonics.layermaps (module)@\spxentry{kppc.photonics.layermaps}\spxextra{module}}\index{load() (in module kppc.photonics.layermaps)@\spxentry{load()}\spxextra{in module kppc.photonics.layermaps}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{photonics/photonics:kppc.photonics.layermaps.load}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{kppc.photonics.layermaps.}}\sphinxbfcode{\sphinxupquote{load}}}{\emph{filename}}{}
Simple routine to read a .layermap file into a dictionary
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}%
\begin{footnote}[79]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#str}
%
\end{footnote}) \textendash{} Filename with path

\item[{Returns}] \leavevmode
Dictionary of dictionaries in the form of \{layer: \{purpose1:(layer\_number,purpose\_number),
purpose2:(layer\_number1,purpose\_number2)\},layer2: \{…\} \}

\item[{Return type}] \leavevmode
\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#dict}{dict}%
\begin{footnote}[80]\sphinxAtStartFootnote
\sphinxnolinkurl{https://docs.python.org/3/library/stdtypes.html\#dict}
%
\end{footnote}

\item[{Examples}] \leavevmode
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{kppc}\PYG{n+nn}{.}\PYG{n+nn}{photonics}\PYG{n+nn}{.}\PYG{n+nn}{layermaps} \PYG{k}{as} \PYG{n+nn}{lm}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{lm}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{expanduser}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZti{}/.klayout/salt/zccmos/FreePDK45\PYGZus{}tech/tech/FreePDK45.layermap}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{\PYGZob{}\PYGZsq{}pwell\PYGZsq{}: \PYGZob{}\PYGZsq{}blockage\PYGZsq{}: (\PYGZsq{}109\PYGZsq{}, \PYGZsq{}1\PYGZsq{}), \PYGZsq{}drawing\PYGZsq{}: (\PYGZsq{}109\PYGZsq{}, \PYGZsq{}0\PYGZsq{})\PYGZcb{}, ... \PYGZcb{}}
\end{sphinxVerbatim}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Example: Create Sample Library}
\label{\detokenize{photonics/example_library:example-create-sample-library}}\label{\detokenize{photonics/example_library::doc}}
In this chapter we will create an example library consisting of an MMI built with a box and linear tapers. This example builds on FreePDK45 technology. Therefore, please get the \sphinxtitleref{KLayoutPhotonicPCells/FreePDK45\_tech} package from the KLayout package manager. The finished file of this example can
be found here \sphinxcode{\sphinxupquote{MMI\_Example}}. This file can be copied into the KLayout pymacros folder (\sphinxcode{\sphinxupquote{\textasciitilde{}/.klayout/pymacros/}}) and executed.


\section{Code Explanation}
\label{\detokenize{photonics/example_library:code-explanation}}
All photonic libraries are derived from {\hyperref[\detokenize{photonics/photonics:kppc.photonics.PhotDevice}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{PhotDevice}}}}}.

As an example, we will use a modified FreePDK45\_Cell. We will create a 2x2 MMI.
To create a new PCell Library open the MacroDevelopment of Klayout in the menu Macros-\textgreater{}MacroDevelopment.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{Macros}.png}
\caption{Open the IDE through \sphinxmenuselection{Macros\(\rightarrow\)MacroDevelopment}}\label{\detokenize{photonics/example_library:id1}}\end{figure}

This will open the KLayout Ruby/Python/DRC IDE. In the left sidebar choose Python as a language. In the menu choose
new (second to the left, the plus sign) to create a new script/library.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{Add_new_Lib}.png}
\caption{Add a new PCell template from the Context}\label{\detokenize{photonics/example_library:id2}}\end{figure}

From the opening context choose \sphinxstyleemphasis{PCell template (Python)}. This will create a new \sphinxtitleref{.lym} file for a PCell-Library.
The generated sample code is irrelevant for us as we will not use KLayout syntax, but the extension.
The reason for choosing the PCell Sample instead of an empty template is, that it will be flagged as a PCell library in
the background.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{Add_new_Lib_2}.png}
\caption{Choose PCell template (Python)}\label{\detokenize{photonics/example_library:id3}}\end{figure}

As a next step delete all example code. The new cell will be created from scratch. Reason for using the sample PCell is that KLayout
uses some flags to define it as a PCell library.

First let’s import modules we will need.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{pya}
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{k+kn}{from} \PYG{n+nn}{kppc.photonics} \PYG{k+kn}{import} \PYG{n}{PhotDevice}\PYG{p}{,} \PYG{n}{PortCreation}
\PYG{k+kn}{import} \PYG{n+nn}{kppc.photonics.layermaps} \PYG{k+kn}{as} \PYG{n+nn}{lm}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\end{sphinxVerbatim}

After the imports we will create a helper class. The class kppc.photonics.PhotDevice is technology-independent and
thus needs to be supplied with information about layers, i.e. how to map layers during dataprep and finally about
the constraints for the DR-Cleaning. So let’s define a helper class that all of our FreePDK45-PCells will use.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=9,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{FreePDK45Example}\PYG{p}{(}\PYG{n}{PhotDevice}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Class that provides technology specific data. Currently the backend needs 3 things to be supplied by the technology of the PCells.}
\PYG{l+s+sd}{    As these are independent of specific PCells and parameters this should not give any difficulty with the requirement of Klayout to have the Classes stateless.}

\PYG{l+s+sd}{    The layermap was created from a forum suggestion}
\PYG{l+s+sd}{        ({}`Post \PYGZlt{}https://community.cadence.com/cadence\PYGZus{}technology\PYGZus{}forums/f/custom\PYGZhy{}ic\PYGZhy{}design/37021/layer\PYGZhy{}map\PYGZhy{}file\PYGZhy{}for\PYGZhy{}gds\PYGZhy{}transfer\PYGZhy{}to\PYGZhy{}virtuoso\PYGZgt{}{}` ) and then some layers were added by hand.}

\PYG{l+s+sd}{        layermap:       A dictionary containing layers with available purposes, which provide a layer/purpose. This is loaded from a .layermap file.}
\PYG{l+s+sd}{                        Example of this FreePDK45:}
\PYG{l+s+sd}{                            \PYGZob{}\PYGZsq{}active\PYGZsq{}: \PYGZob{}\PYGZsq{}blockage\PYGZsq{}: (1, 1), \PYGZsq{}drawing\PYGZsq{}: (1, 0)\PYGZcb{}, \PYGZsq{}pwell\PYGZsq{}: \PYGZob{}\PYGZsq{}blockage\PYGZsq{}: (2, 1), \PYGZsq{}drawing\PYGZsq{}: (2, 0)\PYGZcb{},...\PYGZcb{}}

\PYG{l+s+sd}{        :ivar dataprep\PYGZus{}config: Filepath to a text file containing rules for dataprep. This file contains rules for the dataprep.}
\PYG{l+s+sd}{                        Copied from the example dataprep.txt:}
\PYG{l+s+sd}{                        File Format:}
\PYG{l+s+sd}{                        File defining operations for dataprep}
\PYG{l+s+sd}{                        Format:}
\PYG{l+s+sd}{                        \PYGZlt{}operation\PYGZgt{} \PYGZlt{}source layers\PYGZgt{} \PYGZlt{}destination layers\PYGZgt{} \PYGZlt{}sizing amount in microns\PYGZgt{}}
\PYG{l+s+sd}{                        Operations supported: add,sub}
\PYG{l+s+sd}{                            * add: Create a region from all shapes of the source layers and combine this region with each destion layer region separately}
\PYG{l+s+sd}{                            * sub: Same as add but don\PYGZsq{}t build combination but cross\PYGZhy{}section instead}
\PYG{l+s+sd}{                        Sizing amount uses the klayout sizing operation to size the regions of the source layers}
\PYG{l+s+sd}{                        During dataprep the regions are merged, meaning overlapping polygons will become one Polygon}
\PYG{l+s+sd}{                        source/destination layers are separated by commas if there are multiple}
\PYG{l+s+sd}{                        Each argument is separated by white spaces. How many should not matter as they will be parsed by a python str.split() operation which should be able to handle any white space amount.}
\PYG{l+s+sd}{                        If the first word of a line is not a supported operation the line will be ignored}
\PYG{l+s+sd}{                        The lines will be executed in order meaning and add sub operations on layers will be different than a first sub and then add}
\PYG{l+s+sd}{                        :Examples:}
\PYG{l+s+sd}{                            active.blockage,poly.blockage,metal1.blockage,metal2.blockage,metal3.blockage,metal4.blockage,metal5.blockage,nwell.drawing,nimplant.drawing 2.0}

\PYG{l+s+sd}{        :ivar clean\PYGZus{}rules:     list containing the layer/purpose numbers and the minWidth/minSpacing rules for the layer/purpose pair in microns}
\PYG{l+s+sd}{                        :Examples:}
\PYG{l+s+sd}{                            [[(1, 0), 0.097, 0.077],[(2, 0), 0.23, 0.189],[(3, 0), 0.169, 0.196],[(5, 0), 0.044, 0.052], ...]}
\PYG{l+s+sd}{        \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{c+c1}{\PYGZsh{} Define the metals \PYGZam{} via names. They will be used in some PCells (Electrodes and ViaStack)}
    \PYG{n}{metal\PYGZus{}names} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{metal}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{via\PYGZus{}names} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{via}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{]}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{PhotDevice}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}

        \PYG{n}{techpath} \PYG{o}{=} \PYG{n}{pya}\PYG{o}{.}\PYG{n}{Technology}\PYG{o}{.}\PYG{n}{technology\PYGZus{}by\PYGZus{}name}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FreePDK45}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{base\PYGZus{}path}\PYG{p}{(}\PYG{p}{)}

        \PYG{n}{filename} \PYG{o}{=} \PYG{n}{techpath} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/FreePDK45.tf}\PYG{l+s+s1}{\PYGZsq{}}

        \PYG{c+c1}{\PYGZsh{} Check if techfile is correctly imported and located}

        \PYG{n}{isfile} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{isfile}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
        \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{isfile}\PYG{p}{:}
            \PYG{k+kn}{import} \PYG{n+nn}{sys}
            \PYG{n}{msg} \PYG{o}{=} \PYG{n}{pya}\PYG{o}{.}\PYG{n}{QMessageBox}\PYG{p}{(}\PYG{n}{pya}\PYG{o}{.}\PYG{n}{Application}\PYG{o}{.}\PYG{n}{instance}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{main\PYGZus{}window}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{n}{msg}\PYG{o}{.}\PYG{n}{text} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Please import the techfile of the technology to \PYGZob{}\PYGZcb{} before using the module and reopen KLayout}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
            \PYG{n}{msg}\PYG{o}{.}\PYG{n}{windowTitle} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ImportError}\PYG{l+s+s1}{\PYGZsq{}}
            \PYG{n}{msg}\PYG{o}{.}\PYG{n}{exec\PYGZus{}}\PYG{p}{(}\PYG{p}{)}

        \PYG{n}{tech} \PYG{o}{=} \PYG{n}{con}\PYG{o}{.}\PYG{n}{load\PYGZus{}from\PYGZus{}tech}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Get the layermap file and load it.}
        \PYG{c+c1}{\PYGZsh{} CAREFUL: Will be used for dataprep and others}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layermap} \PYG{o}{=} \PYG{n}{lm}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{n}{techpath} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/FreePDK45.layermap}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} This variable will be imported by the dataprep algorithm}
        \PYG{c+c1}{\PYGZsh{} CAREFUL: Will be imported for dataprep}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dataprep\PYGZus{}config} \PYG{o}{=} \PYG{n}{techpath} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/dataprep.txt}\PYG{l+s+s1}{\PYGZsq{}}

        \PYG{c+c1}{\PYGZsh{} Rules for the cleaner in the form [[(layer1,purpose1),violation\PYGZus{}width1,violation\PYGZus{}space1],[(layer2,purpose2),violation\PYGZus{}width2,violation\PYGZus{}space2],...]}
        \PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{} CAREFUL: This variable will be imported for the cleaning.}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{clean\PYGZus{}rules} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.111}\PYG{p}{,} \PYG{l+m+mf}{0.085}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.23}\PYG{p}{,} \PYG{l+m+mf}{0.188}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.14}\PYG{p}{,} \PYG{l+m+mf}{0.199}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.044}\PYG{p}{,} \PYG{l+m+mf}{0.049}\PYG{p}{]}\PYG{p}{,}
                            \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.046}\PYG{p}{,} \PYG{l+m+mf}{0.052}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.044}\PYG{p}{,} \PYG{l+m+mf}{0.062}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.076}\PYG{p}{,} \PYG{l+m+mf}{0.077}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.073}\PYG{p}{,} \PYG{l+m+mf}{0.089}\PYG{p}{]}\PYG{p}{,}
                            \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.067}\PYG{p}{,} \PYG{l+m+mf}{0.063}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.143}\PYG{p}{,} \PYG{l+m+mf}{0.137}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{19}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.158}\PYG{p}{,} \PYG{l+m+mf}{0.14}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.145}\PYG{p}{,} \PYG{l+m+mf}{0.123}\PYG{p}{]}\PYG{p}{,}
                            \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.514}\PYG{p}{,} \PYG{l+m+mf}{0.535}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.369}\PYG{p}{,} \PYG{l+m+mf}{0.311}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.908}\PYG{p}{,} \PYG{l+m+mf}{0.843}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{29}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.347}\PYG{p}{,} \PYG{l+m+mf}{0.771}\PYG{p}{]}\PYG{p}{,}
                            \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.247}\PYG{p}{,} \PYG{l+m+mf}{1.254}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.976}\PYG{p}{,} \PYG{l+m+mf}{0.905}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.165}\PYG{p}{,} \PYG{l+m+mf}{1.304}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.073}\PYG{p}{,} \PYG{l+m+mf}{0.958}\PYG{p}{]}\PYG{p}{,}
                            \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.058}\PYG{p}{,} \PYG{l+m+mf}{0.885}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.892}\PYG{p}{,} \PYG{l+m+mf}{0.825}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.003}\PYG{p}{,} \PYG{l+m+mf}{0.682}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.983}\PYG{p}{,} \PYG{l+m+mf}{0.73}\PYG{p}{]}\PYG{p}{,}
                            \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.086}\PYG{p}{,} \PYG{l+m+mf}{0.993}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.12}\PYG{p}{,} \PYG{l+m+mf}{0.812}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{19}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.941}\PYG{p}{,} \PYG{l+m+mf}{0.765}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.942}\PYG{p}{,} \PYG{l+m+mf}{0.889}\PYG{p}{]}\PYG{p}{,}
                            \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.044}\PYG{p}{,} \PYG{l+m+mf}{0.933}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.096}\PYG{p}{,} \PYG{l+m+mf}{1.039}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{0.798}\PYG{p}{,} \PYG{l+m+mf}{0.937}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{p}{(}\PYG{l+m+mi}{29}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mf}{1.001}\PYG{p}{,} \PYG{l+m+mf}{1.286}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

This is our basic class. Now let’s create two basic PCells. First a linear taper and second a box. A box combined
with 4 tapers will build a 2x2 MMI. To connect them we will use ports. The liner taper will have two ports, one on
each side. The box will have four ports and each port of the box is the same size as the big part of the taper.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=86,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{ExMMIBody}\PYG{p}{(}\PYG{n}{FreePDK45Example}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}MMI Body. Since this should be a 2x2 MMI it will have 4 ports}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{FreePDK45Example}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}layer}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lay}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{active.drawing}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} Important: If it should be a floating point parameter, use x.0 instead of x for default values that fall on integers, or it will be interpreted as integer}
        \PYG{n}{params} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{length}\PYG{o}{=}\PYG{l+m+mf}{15.}\PYG{p}{,}
                    \PYG{n}{width}\PYG{o}{=}\PYG{l+m+mf}{5.}\PYG{p}{,}
                    \PYG{n}{port\PYGZus{}offset}\PYG{o}{=}\PYG{l+m+mf}{1.5}\PYG{p}{,}
                    \PYG{n}{port\PYGZus{}width} \PYG{o}{=}\PYG{l+m+mf}{1.0}
                    \PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} Register the parameters}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}params}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}param\PYGZus{}inst}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Create Ports here}
        \PYG{n}{ports} \PYG{o}{=} \PYG{p}{[}\PYG{n}{PortCreation}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{port\PYGZus{}offset}\PYG{p}{,} \PYG{l+m+mi}{180}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{port\PYGZus{}width}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{PortCreation}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{port\PYGZus{}offset}\PYG{p}{,} \PYG{l+m+mi}{180}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{port\PYGZus{}width}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{PortCreation}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{port\PYGZus{}offset}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{port\PYGZus{}width}\PYG{p}{)}\PYG{p}{,}
                \PYG{n}{PortCreation}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{port\PYGZus{}offset}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{port\PYGZus{}width}\PYG{p}{)}\PYG{p}{]}
        \PYG{k}{return} \PYG{n}{ports}

    \PYG{k}{def} \PYG{n+nf}{shapes}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{}Create the Rectangle}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{create\PYGZus{}polygon}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{width}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{width}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{width}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{width}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{lay}\PYG{p}{)}

\PYG{k}{class} \PYG{n+nc}{ExLinTaper}\PYG{p}{(}\PYG{n}{FreePDK45Example}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{FreePDK45Example}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}layer}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lay}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{active.drawing}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{params} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{width\PYGZus{}0} \PYG{o}{=} \PYG{o}{.}\PYG{l+m+mi}{5}\PYG{p}{,}
                    \PYG{n}{width\PYGZus{}1} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{,}
                    \PYG{n}{length} \PYG{o}{=} \PYG{l+m+mf}{2.0}\PYG{p}{,}
                    \PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}params}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}param\PYGZus{}inst}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Create left and right port}
        \PYG{n}{port\PYGZus{}0} \PYG{o}{=} \PYG{n}{PortCreation}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{180}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{width\PYGZus{}0}\PYG{p}{)}
        \PYG{n}{port\PYGZus{}1} \PYG{o}{=} \PYG{n}{PortCreation}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{width\PYGZus{}1}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{port\PYGZus{}0}\PYG{p}{,}\PYG{n}{port\PYGZus{}1}

    \PYG{k}{def} \PYG{n+nf}{shapes}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Create taper polygon}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{create\PYGZus{}polygon}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{width\PYGZus{}0}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
                            \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{width\PYGZus{}0}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
                            \PYG{p}{[}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{width\PYGZus{}1}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}
                            \PYG{p}{[}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{width\PYGZus{}1}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{]}\PYG{p}{,}
                            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{lay}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
If we only declare one {\hyperref[\detokenize{photonics/photonics:kppc.photonics.PortCreation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{PortCreation}}}}} in self.create\_param\_inst(self), we have to return it as: \sphinxcode{\sphinxupquote{return {[}port{]}}}
\end{sphinxadmonition}

Now let’s declare the MMI. In it we will create 4 instances of tapers and one box and then connect the tapers to
the box.

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=139,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{Ex2x2MMI}\PYG{p}{(}\PYG{n}{FreePDK45Example}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}The MMI\PYGZhy{}cell class.}
\PYG{l+s+sd}{    This class instantiates a body with 4 tapers and attaches the tapers to the the body.}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{FreePDK45Example}\PYG{o}{.}\PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}layer}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lay}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{active.drawing}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{params} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{wg\PYGZus{}width}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{5}\PYG{p}{,}
                    \PYG{n}{length}\PYG{o}{=}\PYG{l+m+mf}{15.0}\PYG{p}{,}
                    \PYG{n}{taper\PYGZus{}width}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{,}
                    \PYG{n}{taper\PYGZus{}length}\PYG{o}{=}\PYG{l+m+mf}{2.0}\PYG{p}{,}
                    \PYG{n}{width}\PYG{o}{=}\PYG{l+m+mf}{4.0}\PYG{p}{,}
                    \PYG{n}{taper\PYGZus{}offset}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{,}
                    \PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}params}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{create\PYGZus{}param\PYGZus{}inst}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Library we load the sub\PYGZhy{}cells from}
        \PYG{n}{lib} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FreePDK45\PYGZus{}Photonic\PYGZus{}FirstExample}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{bodyname} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MMIBody}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n}{tapername} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LinearTaper}\PYG{l+s+s2}{\PYGZdq{}}

        \PYG{c+c1}{\PYGZsh{} Parameters used for the 4\PYGZhy{}port body}
        \PYG{n}{body\PYGZus{}params} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{lib} \PYG{o}{=} \PYG{n}{lib}\PYG{p}{,}
                            \PYG{n}{cellname} \PYG{o}{=} \PYG{n}{bodyname}\PYG{p}{,}
                            \PYG{n}{width}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{width}\PYG{p}{,}
                            \PYG{n}{length}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{length}\PYG{p}{,}
                            \PYG{n}{port\PYGZus{}offset}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{taper\PYGZus{}offset}\PYG{p}{,}
                            \PYG{n}{port\PYGZus{}width} \PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{taper\PYGZus{}width}\PYG{p}{,}
                            \PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} Parameters for tapers}
        \PYG{n}{taper\PYGZus{}params} \PYG{o}{=} \PYG{n+nb}{dict}\PYG{p}{(}\PYG{n}{lib} \PYG{o}{=} \PYG{n}{lib}\PYG{p}{,}
                            \PYG{n}{cellname} \PYG{o}{=} \PYG{n}{tapername}\PYG{p}{,}
                            \PYG{n}{width\PYGZus{}0}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{wg\PYGZus{}width}\PYG{p}{,}
                            \PYG{n}{width\PYGZus{}1}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{taper\PYGZus{}width}\PYG{p}{,}
                            \PYG{n}{length}\PYG{o}{=}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{taper\PYGZus{}length}\PYG{p}{,}
                            \PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} Create constructors for tapers and body}
        \PYG{n}{tapers} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}pcell\PYGZus{}variant}\PYG{p}{(}\PYG{n}{taper\PYGZus{}params}\PYG{p}{,}\PYG{n}{number}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{)}
        \PYG{n}{body} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{add\PYGZus{}pcell\PYGZus{}variant}\PYG{p}{(}\PYG{n}{body\PYGZus{}params}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Connect the ports}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{:}
            \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{connect\PYGZus{}port\PYGZus{}to\PYGZus{}port}\PYG{p}{(}\PYG{n}{body}\PYG{o}{.}\PYG{n}{port}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,}\PYG{n}{tapers}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{port}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} Return constructors}
        \PYG{k}{return} \PYG{n}{tapers}\PYG{p}{,}\PYG{n}{body}
\end{sphinxVerbatim}

Finally create the Library so that we can call it in KLayout:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=188,stepnumber=1]
\PYG{k}{class} \PYG{n+nc}{FreePDK45\PYGZus{}ExampleLib}\PYG{p}{(}\PYG{n}{pya}\PYG{o}{.}\PYG{n}{Library}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{} Set the description}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{description} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FirstExample}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{technology} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FreePDK45}\PYG{l+s+s2}{\PYGZdq{}}
        \PYG{c+c1}{\PYGZsh{} Create the PCell declarations}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layout}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{register\PYGZus{}pcell}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2x2MMI}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{Ex2x2MMI}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layout}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{register\PYGZus{}pcell}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MMIBody}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ExMMIBody}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{layout}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{register\PYGZus{}pcell}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LinearTaper}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{ExLinTaper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{register}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FreePDK45\PYGZus{}Photonic\PYGZus{}FirstExample}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

And finally make KLayout compile the PCell-Library and add it to the PCell-Libraries:

\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=200,stepnumber=1]
\PYG{c+c1}{\PYGZsh{} Instantiate and register the library}
\PYG{n}{FreePDK45\PYGZus{}ExampleLib}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

Click \sphinxcode{\sphinxupquote{Run script from the current tab}} (Green Arrow with a vertical line at the end).

Now you can create Instances of this parametric cell in the main window of Klayout. Click on Instance and
choose the \sphinxcode{\sphinxupquote{FreePDK Sample Cells {[}Technology FreePDK45{]}}} library from the drop-down menu. On the left of the library
drop down you can choose one of the three cells. And in the tab you can adjust parameters.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[width=1.000\linewidth]{{Instance}.png}
\caption{In the main window click on Instance to create instances of the new Cell}\label{\detokenize{photonics/example_library:id4}}\end{figure}

If you click \sphinxstylestrong{Ok} or \sphinxstylestrong{Apply} you can place the new Cell with adjusted parameters. The first boolean determines
whether the cell should contain only dataprep \& design rule cleaned shapes or all shapes. The second tells the
cell to perform dataprep and the last to make it DR-clean. The rest of the parameters are PCell specific and should
be the ones defined in the \sphinxcode{\sphinxupquote{\_\_init\_\_(self)}} function of the cell definition.


\chapter{Tips \& Tricks}
\label{\detokenize{tips:tips-tricks}}\label{\detokenize{tips::doc}}

\section{Variable Names in KLayout Python}
\label{\detokenize{tips:variable-names-in-klayout-python}}
When using global variables in pymacros (scripts like cell libraries) be careful. Namespace is shared between macros. This means when for example defining the names of metal layers in two cells, one can overwrite the other one.
Therefore the use of global variables is not advised and the use of a wrapper class is recommended instead. It can be defined in the same wrapper class used for defining layernames and cleaning information, for example.


\chapter{C++ Source Code}
\label{\detokenize{sourcecodes:c-source-code}}\label{\detokenize{sourcecodes::doc}}

\section{DrcSl Source}
\label{\detokenize{source_code/drcsl_source:drcsl-source}}\label{\detokenize{source_code/drcsl_source:drcslsource}}\label{\detokenize{source_code/drcsl_source::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//  This file is part of KLayoutPhotonicPCells, an extension for Photonic Layouts in KLayout.}
\PYG{c+c1}{//  Copyright (c) 2018, Sebastian Goeldi}
\PYG{c+c1}{//}
\PYG{c+c1}{//    This program is free software: you can redistribute it and/or modify}
\PYG{c+c1}{//    it under the terms of the GNU Affero General Public License as}
\PYG{c+c1}{//    published by the Free Software Foundation, either version 3 of the}
\PYG{c+c1}{//    License, or (at your option) any later version.}
\PYG{c+c1}{//}
\PYG{c+c1}{//    This program is distributed in the hope that it will be useful,}
\PYG{c+c1}{//    but WITHOUT ANY WARRANTY; without even the implied warranty of}
\PYG{c+c1}{//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
\PYG{c+c1}{//    GNU Affero General Public License for more details.}
\PYG{c+c1}{//}
\PYG{c+c1}{//    You should have received a copy of the GNU Affero General Public License}
\PYG{c+c1}{//    along with this program.  If not, see \PYGZlt{}https://www.gnu.org/licenses/\PYGZgt{}.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}DrcSl.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}boost/interprocess/managed\PYGZus{}shared\PYGZus{}memory.hpp\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}boost/interprocess/containers/vector.hpp\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}boost/interprocess/allocators/allocator.hpp\PYGZgt{}}




\PYG{k}{namespace} \PYG{n}{drclean}
\PYG{p}{\PYGZob{}}

\PYG{c+c1}{//    Function to compare two edgecoord structs. This is necessary for std::sort. If they are on the same coordinate sort for type in descending order}
\PYG{k+kt}{bool} \PYG{n}{compare\PYGZus{}edgecoord}\PYG{p}{(}\PYG{n}{edgecoord} \PYG{n}{e1}\PYG{p}{,} \PYG{n}{edgecoord} \PYG{n}{e2}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{e1}\PYG{p}{.}\PYG{n}{pos}\PYG{o}{=}\PYG{o}{=}\PYG{n}{e2}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{)}
        \PYG{k}{return} \PYG{p}{(}\PYG{n}{e2}\PYG{p}{.}\PYG{n}{type}\PYG{o}{\PYGZlt{}}\PYG{n}{e1}\PYG{p}{.}\PYG{n}{type}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{else}
        \PYG{n+nf}{return} \PYG{p}{(}\PYG{n}{e1}\PYG{p}{.}\PYG{n}{pos}\PYG{o}{\PYGZlt{}}\PYG{n}{e2}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Constructor. Initialize the pointers as nullptrs}
\PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DrcSl}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Destructor: Delete the allocated vectors.}
\PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{o}{\PYGZti{}}\PYG{n}{DrcSl}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor} \PYG{o}{!}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver} \PYG{o}{!}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Add a complete data\PYGZhy{}set. Currently not used and not exposed in the Python interface.}
\PYG{k+kt}{int} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{set\PYGZus{}data}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{horlist}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l} \PYG{o}{=} \PYG{n}{horlist}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Initialize the dimensions of the vector arrays and set pointers accordingly and dimension units.}
\PYG{k+kt}{void} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{initialize\PYGZus{}list}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{hor1}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{hor2}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{ver1}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{ver2}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{violation\PYGZus{}space}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{violation\PYGZus{}width}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor}\PYG{p}{;}
        \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver}\PYG{p}{;}
        \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor} \PYG{o}{=} \PYG{k}{new} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{n}{ver2}\PYG{o}{\PYGZhy{}}\PYG{n}{ver1}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver} \PYG{o}{=} \PYG{k}{new} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{n}{hor2}\PYG{o}{\PYGZhy{}}\PYG{n}{hor1}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sver} \PYG{o}{=} \PYG{n}{hor2}\PYG{o}{\PYGZhy{}}\PYG{n}{hor1}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{shor} \PYG{o}{=} \PYG{n}{ver2}\PYG{o}{\PYGZhy{}}\PYG{n}{ver1}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hor1} \PYG{o}{=} \PYG{n}{hor1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hor2} \PYG{o}{=} \PYG{n}{hor2}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ver1} \PYG{o}{=} \PYG{n}{ver1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ver2} \PYG{o}{=} \PYG{n}{ver2}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{violation\PYGZus{}space} \PYG{o}{=} \PYG{n}{violation\PYGZus{}space}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{violation\PYGZus{}width} \PYG{o}{=} \PYG{n}{violation\PYGZus{}width}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{=} \PYG{n}{hor}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Print the complete data set or from index beg \PYGZhy{}\PYGZgt{} end if they are set.}
\PYG{c+c1}{//    \PYGZhy{}1, \PYGZhy{}1 will result in printing the whole vector.}
\PYG{k+kt}{void} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{printvector}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{beg}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{last}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{last} \PYG{o}{=}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{beg} \PYG{o}{=}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{last} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver2} \PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hor2}\PYG{p}{;}
        \PYG{n}{beg} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver1} \PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hor1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it}\PYG{p}{;}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{size, y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sver} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{size, x: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{shor} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{offset} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nl}{hor1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{ver1}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{offset\PYGZus{}d2} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{hor1}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{beg/end }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{beg}\PYG{o}{+}\PYG{n}{offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{/}\PYG{l+s+sc}{\PYGZsq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{last}\PYG{o}{+}\PYG{n}{offset}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{row: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: [}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{n}{it} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}}\PYG{n}{offset\PYGZus{}d2}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{type} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Get the current array size of the vectors}
\PYG{k+kt}{int} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{sver} \PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{shor}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{//  Sort all data with compare\PYGZus{}edge\PYGZus{}coord and remove overlapping edges, i.e. merge overlapping polygons in the data}
\PYG{k+kt}{void} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sortlist}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{//        std::cout \PYGZlt{}\PYGZlt{} this\PYGZhy{}\PYGZgt{}s() \PYGZlt{}\PYGZlt{} std::endl;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sort}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{compare\PYGZus{}edgecoord}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it}\PYG{p}{;}
            \PYG{n}{it} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{type} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{k}{if} \PYG{p}{(}\PYG{n}{c}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{c}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rem} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{if} \PYG{p}{(}\PYG{n}{c}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{c}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rem} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{remove\PYGZus{}if}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{auto} \PYG{n}{o}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{o}\PYG{p}{.}\PYG{n}{rem}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Get data from a row (or column).}
\PYG{c+c1}{//    If used after the standard sorting or cleaning function, i.e. sortlist() and cleaning(),}
\PYG{c+c1}{//    the vectors should always be arranged row\PYGZhy{}oriented, meaning the same format as when added to the cleaner.}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{get\PYGZus{}vect}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ind}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{offset} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{hor1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{ver1}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{offset\PYGZus{}d2} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{hor1}\PYG{p}{;}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{res} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{ind}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n}{it} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{ind}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{ind}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{type}\PYG{p}{)}
            \PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{p}{(}\PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{offset\PYGZus{}d2}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{else}
            \PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{p}{(}\PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{offset\PYGZus{}d2}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Function to print the types in a vector. Probably only useful for debugging purposes}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{get\PYGZus{}types}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ind}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{offset} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{hor1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{ver1}\PYG{p}{;}

    \PYG{n}{offset} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{res} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{ind}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n}{it} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{ind}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{ind}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{type}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Add data to the data structure. We manhattanize the edge from the input and mark left facing edges with \PYGZhy{}1 and}
\PYG{c+c1}{//    right facing edges with +1. The get\PYGZus{}vect() function reverses this effect.}
\PYG{c+c1}{//    This should have no influence on any possible data except that it merges touching polygons.}
\PYG{k+kt}{void} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{add\PYGZus{}data}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{px1}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{px2}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{py1}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{py2}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{offset} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nl}{hor1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{ver1}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{offset\PYGZus{}d2} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{hor1}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{py2} \PYG{o}{\PYGZgt{}} \PYG{n}{py1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{edgecoord} \PYG{n}{p}  \PYG{o}{=} \PYG{n}{edgecoord}\PYG{p}{(}\PYG{n}{px1}\PYG{o}{+}\PYG{n}{offset\PYGZus{}d2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kt}{double} \PYG{n}{dx} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{p}{(}\PYG{n}{px2}\PYG{o}{\PYGZhy{}}\PYG{n}{px1}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{py2}\PYG{o}{\PYGZhy{}}\PYG{n}{py1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{x} \PYG{o}{=} \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{shor} \PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sver}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error ROW (y) index out of bound }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{/}\PYG{l+s+sc}{\PYGZsq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{shor}\PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sver}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{offset}\PYG{o}{+}\PYG{n}{py1} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{py2}\PYG{o}{+}\PYG{n}{offset} \PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{sver} \PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{shor}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error COLUMN (x) index out of bound}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{py2}\PYG{o}{+}\PYG{n}{offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{l+m+mi}{2}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{dx} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{offset}\PYG{o}{+}\PYG{n}{py1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{py2}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{x}\PYG{o}{+}\PYG{o}{=}\PYG{n}{dx}\PYG{p}{;}
                \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{=} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{offset}\PYG{o}{+}\PYG{n}{py1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{py2}\PYG{o}{+}\PYG{n}{offset}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{x}\PYG{o}{+}\PYG{o}{=}\PYG{n}{dx}\PYG{p}{;}
                \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{=} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{=} \PYG{n}{px2}\PYG{o}{+}\PYG{n}{offset\PYGZus{}d2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{py2}\PYG{o}{+}\PYG{n}{offset}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{py1} \PYG{o}{\PYGZgt{}} \PYG{n}{py2}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{edgecoord} \PYG{n}{p}  \PYG{o}{=} \PYG{n}{edgecoord}\PYG{p}{(}\PYG{n}{px2}\PYG{o}{+}\PYG{n}{offset\PYGZus{}d2}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kt}{double} \PYG{n}{dx} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{p}{(}\PYG{n}{px1}\PYG{o}{\PYGZhy{}}\PYG{n}{px2}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{py1}\PYG{o}{\PYGZhy{}}\PYG{n}{py2}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{x} \PYG{o}{=} \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{shor} \PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sver}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error ROW (y) index out of bound }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{/}\PYG{l+s+sc}{\PYGZsq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{shor}\PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sver}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{offset}\PYG{o}{+}\PYG{n}{py1} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{py2}\PYG{o}{+}\PYG{n}{offset} \PYG{o}{\PYGZgt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error COLUMN (x) index out of bound}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{l+m+mi}{2}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{dx} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{offset}\PYG{o}{+}\PYG{n}{py2}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{py1}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{x}\PYG{o}{+}\PYG{o}{=}\PYG{n}{dx}\PYG{p}{;}
                \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ceil}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{offset}\PYG{o}{+}\PYG{n}{py2}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{py1}\PYG{o}{+}\PYG{n}{offset}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{x}\PYG{o}{+}\PYG{o}{=}\PYG{n}{dx}\PYG{p}{;}
                \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ceil}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{=} \PYG{n}{px1}\PYG{o}{+}\PYG{n}{offset\PYGZus{}d2}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{py1}\PYG{o}{+}\PYG{n}{offset}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Clean data for space violations in the current orientation (row\PYGZhy{}oriented for violations within the row and accordingly if column\PYGZhy{}oriented).}
\PYG{k+kt}{int} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{clean\PYGZus{}space}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//Cleans space violations.}
    \PYG{c+c1}{//Returns number of space violations that were cleaned.}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{il} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{;}

    \PYG{c+c1}{//Counters to keep track of how many checks were done and how many space violations have been cleaned.}
    \PYG{k+kt}{int} \PYG{n}{spacevios} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{counts} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{bool} \PYG{n}{er} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{n}{it} \PYG{o}{=} \PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{it} \PYG{o}{=}\PYG{o}{=} \PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{continue}\PYG{p}{;}
            \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{it}\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{o}{!}\PYG{o}{=} \PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{counts}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{it}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZlt{}} \PYG{n}{violation\PYGZus{}space} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{er} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{n}{spacevios}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rem} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{p}{(}\PYG{n}{it}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rem} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{it}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{er}\PYG{p}{)}
                \PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{remove\PYGZus{}if}\PYG{p}{(}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{auto} \PYG{n}{o}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{o}\PYG{p}{.}\PYG{n}{rem}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{il}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//        If progress output is desired uncomment the following lines}
\PYG{c+c1}{//        std::cout \PYGZlt{}\PYGZlt{} \PYGZdq{}number of checks: \PYGZdq{} \PYGZlt{}\PYGZlt{} counts \PYGZlt{}\PYGZlt{} std::endl;}
\PYG{c+c1}{//        std::cout \PYGZlt{}\PYGZlt{} \PYGZdq{}violations, space: \PYGZdq{} \PYGZlt{}\PYGZlt{} spacevios \PYGZlt{}\PYGZlt{} std::endl;}
    \PYG{k}{return} \PYG{n}{spacevios}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Clean data for width violation}
\PYG{k+kt}{int} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{clean\PYGZus{}width}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{il} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{widthvios} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{counts} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{bool} \PYG{n}{er}\PYG{o}{=}\PYG{n+nb}{false}\PYG{p}{;}
            \PYG{n}{it} \PYG{o}{=} \PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{counts}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{it}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZlt{}} \PYG{n}{violation\PYGZus{}width} \PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{er} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rem} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{p}{(}\PYG{n}{it}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rem} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{n}{widthvios}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{it}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{er}\PYG{p}{)}
                \PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{remove\PYGZus{}if}\PYG{p}{(}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{auto} \PYG{n}{o}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{o}\PYG{p}{.}\PYG{n}{rem}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

        \PYG{p}{\PYGZcb{}}
        \PYG{n}{il}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//        If progress output is desired uncomment the following lines}
\PYG{c+c1}{//        std::cout \PYGZlt{}\PYGZlt{} \PYGZdq{}number of checks: \PYGZdq{} \PYGZlt{}\PYGZlt{} counts \PYGZlt{}\PYGZlt{} std::endl;}
\PYG{c+c1}{//        std::cout \PYGZlt{}\PYGZlt{} \PYGZdq{}violations, width: \PYGZdq{} \PYGZlt{}\PYGZlt{} widthvios \PYGZlt{}\PYGZlt{} std::endl;}
    \PYG{k}{return} \PYG{n}{widthvios}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{//    Calculate difference between two rows or two columns. This is necessary when switching from row\PYGZhy{}oriented to}
\PYG{c+c1}{//    column\PYGZhy{}oriented data and vice\PYGZhy{}versa.}
\PYG{c+c1}{//}
\PYG{c+c1}{//    In theory this can also be used to check for minimum edge\PYGZhy{}lengths. But for us all of these requirements have been}
\PYG{c+c1}{//    waived, so we don\PYGZsq{}t have to check for those.}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{listdif}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{l1}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{l2}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/*}
\PYG{c+cm}{    **  Calculates differences between rows (or columns, depending on orientation) between two vectors (rows/columns)}
\PYG{c+cm}{    **  The difference between the two vectors indicate that there is a polygon border for the other orientation of the scanlines}
\PYG{c+cm}{    **  This border corresponds to edges and thus has to appear in the opposite orientation}
\PYG{c+cm}{    */}

    \PYG{c+cm}{/*}
\PYG{c+cm}{    **  Example:}
\PYG{c+cm}{    **}
\PYG{c+cm}{    **  l1 is the row/column that we compare to. Any coordinates that appear in l1, but not in l2, will be returned as ranges.}
\PYG{c+cm}{    **  example:}
\PYG{c+cm}{    **  l1 = ([1,5],[7,10],[18,20])}
\PYG{c+cm}{    **  l2 = ([4,11],[15,16])}
\PYG{c+cm}{    **  out = ([1,3],[18,20])}
\PYG{c+cm}{    */}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{out}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it1} \PYG{o}{=} \PYG{n}{l1}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it2} \PYG{o}{=} \PYG{n}{l2}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{l21}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{l22}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{it1} \PYG{o}{=} \PYG{n}{l1}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it1} \PYG{o}{!}\PYG{o}{=}\PYG{n}{l1}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it1}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{b} \PYG{o}{=} \PYG{n}{it1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{p}{;}
        \PYG{n}{it1}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{e} \PYG{o}{=} \PYG{n}{it1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{ee} \PYG{o}{=} \PYG{n}{e}\PYG{p}{;}
        \PYG{k+kt}{bool} \PYG{n}{add} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{it2} \PYG{o}{!}\PYG{o}{=} \PYG{n}{l2}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{l21} \PYG{o}{=} \PYG{n}{it2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{p}{;}
            \PYG{n}{l22} \PYG{o}{=} \PYG{p}{(}\PYG{n}{it2}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{l22} \PYG{o}{\PYGZlt{}} \PYG{n}{b}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{it2}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{l22} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{e}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{e} \PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{l21} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{b}\PYG{p}{)}
                    \PYG{n}{add} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{e} \PYG{o}{\PYGZgt{}} \PYG{n}{l21} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
                    \PYG{n}{e} \PYG{o}{=} \PYG{n}{l21} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{l22} \PYG{o}{\PYGZlt{}} \PYG{n}{e} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{l21} \PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{out}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{out}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{l21} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{b} \PYG{o}{=} \PYG{n}{l22} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{n}{e} \PYG{o}{=} \PYG{n}{ee}\PYG{p}{;}
                \PYG{n}{it2} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{l22} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{b} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{b} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{l21}\PYG{p}{)}
                \PYG{n}{b} \PYG{o}{=} \PYG{n}{l22} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{l21} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{e} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{e} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{l22}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{e} \PYG{o}{=} \PYG{n}{l21} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}

        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{add}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{out}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{out}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{out}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{//    Switch dimensions. When calculating listdiffs between two rows, we can calculate the edges in row direction when}
\PYG{c+c1}{//    row\PYGZhy{}oriented or in column direction when column\PYGZhy{}oriented. These edges then give us column\PYGZhy{}orientation data and vice\PYGZhy{}versa.}
\PYG{k+kt}{void} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/*}
\PYG{c+cm}{    **  Switch row to column orientation of the scanlines.}
\PYG{c+cm}{    **  Example:}
\PYG{c+cm}{    **}
\PYG{c+cm}{    **  5: 	[]}
\PYG{c+cm}{    **  6: 	[]}
\PYG{c+cm}{    **  7:	[(4,0),(10,1)]}
\PYG{c+cm}{    **  8:	[(3,0),(7,1),(8,0),(11,1)]}
\PYG{c+cm}{    **  9:	[(3,0),(8,1),(8,0),(11,1)]}
\PYG{c+cm}{    **  10:	[(4,0),(8,0),(8,1),(12,1)]}
\PYG{c+cm}{    **  11:	[(4,0),(7,1)]}
\PYG{c+cm}{    **  12:	[]}
\PYG{c+cm}{    **  13:	[]}
\PYG{c+cm}{    **}
\PYG{c+cm}{    **  Will be converted to:}
\PYG{c+cm}{    **}
\PYG{c+cm}{    **  3:	[]}
\PYG{c+cm}{    **  4:	[(7,0),(10,1)]}
\PYG{c+cm}{    **  5:	[(6,0),(12,1)]}
\PYG{c+cm}{    **  6:	[(6,0),(12,1)]}
\PYG{c+cm}{    **  7:	[(6,0),(8,1),(8,0),(11,1)]}
\PYG{c+cm}{    **  8:	[(6,0),(8,1)]}
\PYG{c+cm}{    **  9:	[(6,0),(11,1)]}
\PYG{c+cm}{    **  10:	[(7,0),(11,1)]}
\PYG{c+cm}{    **  11:	[(9,0),(11,1)]}
\PYG{c+cm}{    **  12:	[]}
\PYG{c+cm}{    **}
\PYG{c+cm}{    */}

\PYG{c+c1}{//        If progress output is desired uncomment the following lines}
\PYG{c+c1}{//        std::cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Switching dimensions\PYGZdq{} \PYGZlt{}\PYGZlt{} std::endl;}
    \PYG{k}{if}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
        \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor} \PYG{o}{=} \PYG{k}{new} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ver2}\PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ver1}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
        \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver} \PYG{o}{=} \PYG{k}{new} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hor2}\PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hor1}\PYG{p}{]}\PYG{p}{;}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{l\PYGZus{}new}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{shor}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{l\PYGZus{}new} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sver}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{l\PYGZus{}new} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{n}{row\PYGZus{}last}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{n}{row}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{n}{row\PYGZus{}next}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{it} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{dit}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{dif1}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{dif2}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{rit}\PYG{p}{;}
    \PYG{n}{row\PYGZus{}last} \PYG{o}{=} \PYG{o}{*}\PYG{n}{it}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n}{rit} \PYG{o}{=} \PYG{n}{row\PYGZus{}last}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{rit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{row\PYGZus{}last}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{rit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{rit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{rit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{rit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{it} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{n}{row} \PYG{o}{=} \PYG{o}{*}\PYG{n}{it}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n}{rit} \PYG{o}{=} \PYG{n}{row}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{rit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{row}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{rit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{rit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{rit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{rit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{row\PYGZus{}number} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{row\PYGZus{}next} \PYG{o}{=} \PYG{o}{*}\PYG{n}{it}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{n}{rit} \PYG{o}{=} \PYG{n}{row\PYGZus{}next}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{rit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{row\PYGZus{}next}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{rit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{rit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{rit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{rit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{n}{dif1} \PYG{o}{=} \PYG{n}{listdif}\PYG{p}{(}\PYG{n}{row\PYGZus{}last}\PYG{p}{,}\PYG{n}{row}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{dif2} \PYG{o}{=} \PYG{n}{listdif}\PYG{p}{(}\PYG{n}{row\PYGZus{}next}\PYG{p}{,}\PYG{n}{row}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{e}\PYG{p}{;}
        \PYG{n}{dit} \PYG{o}{=} \PYG{n}{dif1}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{dit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{dif1}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{b} \PYG{o}{=} \PYG{o}{*}\PYG{n}{dit}\PYG{p}{;}
            \PYG{n}{dit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{e} \PYG{o}{=} \PYG{o}{*}\PYG{n}{dit}\PYG{p}{;}
            \PYG{n}{dit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{k}{for} \PYG{p}{(}\PYG{p}{;} \PYG{n}{b}\PYG{o}{!}\PYG{o}{=}\PYG{n}{e}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{b}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{edgecoord} \PYG{n}{p} \PYG{o}{=} \PYG{n}{edgecoord}\PYG{p}{(}\PYG{n}{row\PYGZus{}number}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{l\PYGZus{}new}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{dit} \PYG{o}{=} \PYG{n}{dif2}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{dit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{dif2}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{b} \PYG{o}{=} \PYG{o}{*}\PYG{n}{dit}\PYG{p}{;}
            \PYG{n}{dit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{e} \PYG{o}{=} \PYG{o}{*}\PYG{n}{dit}\PYG{p}{;}
            \PYG{n}{dit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{k}{for} \PYG{p}{(}\PYG{p}{;} \PYG{n}{b}\PYG{o}{!}\PYG{o}{=}\PYG{n}{e}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{b}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{edgecoord} \PYG{n}{p} \PYG{o}{=} \PYG{n}{edgecoord}\PYG{p}{(}\PYG{n}{row\PYGZus{}number}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{l\PYGZus{}new}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{row\PYGZus{}last} \PYG{o}{=} \PYG{n}{row}\PYG{p}{;}
        \PYG{n}{row} \PYG{o}{=} \PYG{n}{row\PYGZus{}next}\PYG{p}{;}
        \PYG{n}{row\PYGZus{}number}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l} \PYG{o}{=} \PYG{n}{l\PYGZus{}new}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{orientation} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{n+nl}{hor} \PYG{p}{:} \PYG{n}{ver}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{//    Function that first cleans space violations then width violations and then space violations again.}
\PYG{c+c1}{//    This does not necessarily clean all violations. For example if a fixing of a width violation creates a space violation}
\PYG{c+c1}{//    and vice\PYGZhy{}versa, the algorithm will not fix the violation. For performance reasons}
\PYG{c+c1}{//    it is still the user\PYGZsq{}s task to perform DRC and ensure the design is clean. For standard photonic structures it is}
\PYG{c+c1}{//    unlikely that such a case occurs.}
\PYG{k+kt}{void} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{clean}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{maxtries}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{maxtries}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{clean\PYGZus{}space}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{clean\PYGZus{}space}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{continue}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                    If progress output is desired uncomment the following lines}
\PYG{c+c1}{//                    std::cout\PYGZlt{}\PYGZlt{} \PYGZdq{}Finished after \PYGZdq{} \PYGZlt{}\PYGZlt{} i+1 \PYGZlt{}\PYGZlt{} \PYGZdq{} tries\PYGZdq{} \PYGZlt{}\PYGZlt{} std::endl;}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{maxtries}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{clean\PYGZus{}width}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                If progress output is desired uncomment the following lines}
\PYG{c+c1}{//                std::cout\PYGZlt{}\PYGZlt{} \PYGZdq{}Try: \PYGZdq{} \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} \PYGZdq{}/\PYGZdq{} \PYGZlt{}\PYGZlt{} maxtries \PYGZlt{}\PYGZlt{} std::endl;}
            \PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{clean\PYGZus{}width}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{continue}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                    If progress output is desired uncomment the following lines}
\PYG{c+c1}{//                    std::cout\PYGZlt{}\PYGZlt{} \PYGZdq{}Finished after \PYGZdq{} \PYGZlt{}\PYGZlt{} i+1 \PYGZlt{}\PYGZlt{} \PYGZdq{} tries\PYGZdq{} \PYGZlt{}\PYGZlt{} std::endl;}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{maxtries}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{clean\PYGZus{}space}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                If progress output is desired uncomment the following lines}
\PYG{c+c1}{//                std::cout\PYGZlt{}\PYGZlt{} \PYGZdq{}Try: \PYGZdq{} \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} \PYGZdq{}/\PYGZdq{} \PYGZlt{}\PYGZlt{} maxtries \PYGZlt{}\PYGZlt{} std::endl;}
            \PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{clean\PYGZus{}space}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                        If progress output is desired uncomment the following lines}
\PYG{c+c1}{//                        std::cout\PYGZlt{}\PYGZlt{} \PYGZdq{}Finished after \PYGZdq{} \PYGZlt{}\PYGZlt{} i+1 \PYGZlt{}\PYGZlt{} \PYGZdq{} tries\PYGZdq{} \PYGZlt{}\PYGZlt{} std::endl;}
                    \PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{break}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//        If progress output is desired uncomment the following lines}
\PYG{c+c1}{//        std::cout\PYGZlt{}\PYGZlt{} \PYGZdq{}Done cleaning\PYGZdq{} \PYGZlt{}\PYGZlt{} std::endl;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{get\PYGZus{}lines}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lines} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{offset\PYGZus{}d2} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{hor1}\PYG{p}{;}

    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{n+nl}{iter}\PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{lines}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{iter}\PYG{p}{.}\PYG{n}{type} \PYG{o}{?} \PYG{n}{iter}\PYG{p}{.}\PYG{n}{pos}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nl}{offset\PYGZus{}d2} \PYG{p}{:} \PYG{n}{iter}\PYG{p}{.}\PYG{n}{pos}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{offset\PYGZus{}d2}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{lines}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{pi}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{get\PYGZus{}polygons}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{splits}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{polygons}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{offset} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nl}{hor1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{ver1}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{offset\PYGZus{}d1} \PYG{o}{=} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{hor1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{offset\PYGZus{}d2} \PYG{o}{=} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{hor1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}

    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{y} \PYG{o}{=} \PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{n}{offset}\PYG{p}{;}
        \PYG{k+kt}{bool} \PYG{n}{advance} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{n}{spv}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{spit} \PYG{o}{=} \PYG{n}{splits}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ev}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{append\PYGZus{}first} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ev}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{append\PYGZus{}last} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{for}\PYG{p}{(}\PYG{n}{ev}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{ei} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{ei} \PYG{o}{!}\PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{ei}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{x1} \PYG{o}{=} \PYG{n}{ei}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d1}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{x2} \PYG{o}{=} \PYG{p}{(}\PYG{n}{ei}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d2}\PYG{p}{;}

            \PYG{k}{if}\PYG{p}{(}\PYG{n}{advance}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{spit} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{find\PYGZus{}if}\PYG{p}{(}\PYG{n}{splits}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{splits}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x1}\PYG{p}{,}\PYG{n}{x2}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{offset\PYGZus{}d2}\PYG{p}{,}\PYG{n}{offset\PYGZus{}d1}\PYG{p}{]} \PYG{p}{(}\PYG{n}{SplitPolygon} \PYG{o}{\PYGZam{}} \PYG{n}{sp}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{return} \PYG{p}{(}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{end} \PYG{o}{=}\PYG{o}{=}\PYG{n}{y}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{erx} \PYG{o}{\PYGZlt{}} \PYG{n}{x1}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{elx} \PYG{o}{\PYGZgt{}} \PYG{n}{x2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{advance} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}

            \PYG{k}{if}\PYG{p}{(}\PYG{n}{spit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{splits}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{ex1} \PYG{o}{=} \PYG{n}{spit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{elx}\PYG{p}{;}
                \PYG{k+kt}{int} \PYG{n}{ex2} \PYG{o}{=} \PYG{n}{spit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{erx}\PYG{p}{;}

                \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x1} \PYG{o}{\PYGZgt{}} \PYG{n}{ex2}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{x2} \PYG{o}{\PYGZlt{}} \PYG{n}{ex1}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{spit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end} \PYG{o}{=}\PYG{o}{=} \PYG{n}{y}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k+kt}{int} \PYG{n}{l} \PYG{o}{=} \PYG{n}{append\PYGZus{}last} \PYG{o}{\PYGZhy{}} \PYG{n}{append\PYGZus{}first}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{l} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{spit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{append}\PYG{p}{(}\PYG{n}{append\PYGZus{}first}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d1}\PYG{p}{,} \PYG{p}{(}\PYG{n}{append\PYGZus{}first}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}}\PYG{n}{offset\PYGZus{}d2}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{l} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k+kt}{int} \PYG{n}{merge\PYGZus{}ind} \PYG{o}{=} \PYG{n}{spit} \PYG{o}{\PYGZhy{}} \PYG{n}{splits}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                        \PYG{k}{for}\PYG{p}{(}\PYG{n}{ev}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{eit} \PYG{o}{=} \PYG{n}{append\PYGZus{}first}\PYG{p}{;} \PYG{n}{eit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{append\PYGZus{}last}\PYG{p}{;} \PYG{n}{eit} \PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{SplitPolygon} \PYG{n}{sp} \PYG{o}{=} \PYG{n}{SplitPolygon}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{init}\PYG{p}{(}\PYG{n}{eit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d1}\PYG{p}{,}\PYG{p}{(}\PYG{n}{eit}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d2}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
                            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{merge\PYGZus{}ind} \PYG{o}{=} \PYG{n}{merge\PYGZus{}ind}\PYG{p}{;}
                            \PYG{n}{splits}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{spit} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{find\PYGZus{}if}\PYG{p}{(}\PYG{n}{splits}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{splits}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x1}\PYG{p}{,}\PYG{n}{x2}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{offset\PYGZus{}d2}\PYG{p}{,}\PYG{n}{offset\PYGZus{}d1}\PYG{p}{]} \PYG{p}{(}\PYG{n}{SplitPolygon} \PYG{o}{\PYGZam{}} \PYG{n}{sp}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{return} \PYG{p}{(}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{end} \PYG{o}{=}\PYG{o}{=}\PYG{n}{y}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{erx} \PYG{o}{\PYGZlt{}} \PYG{n}{x1}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{elx} \PYG{o}{\PYGZgt{}} \PYG{n}{x2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{spit} \PYG{o}{=}\PYG{o}{=} \PYG{n}{splits}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{SplitPolygon} \PYG{n}{sp} \PYG{o}{=} \PYG{n}{SplitPolygon}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{init}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,}\PYG{n}{x2}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{splits}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{append\PYGZus{}first} \PYG{o}{=} \PYG{n}{ei} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{;}
                        \PYG{n}{append\PYGZus{}last} \PYG{o}{=} \PYG{n}{ei} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{;}
                        \PYG{n}{advance} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{else}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{append\PYGZus{}first} \PYG{o}{=} \PYG{n}{ei}\PYG{p}{;}
                        \PYG{n}{append\PYGZus{}last} \PYG{o}{=} \PYG{n}{ei}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{append\PYGZus{}last} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{SplitPolygon} \PYG{n}{sp} \PYG{o}{=} \PYG{n}{SplitPolygon}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sp}\PYG{p}{.}\PYG{n}{init}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,}\PYG{n}{x2}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{splits}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{append\PYGZus{}first} \PYG{o}{=} \PYG{n}{ei} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{;}
                \PYG{n}{append\PYGZus{}last} \PYG{o}{=} \PYG{n}{ei} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{;}
                \PYG{n}{advance} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{k+kt}{int} \PYG{n}{l} \PYG{o}{=} \PYG{n}{append\PYGZus{}last} \PYG{o}{\PYGZhy{}} \PYG{n}{append\PYGZus{}first}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{l} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{spit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{append}\PYG{p}{(}\PYG{n}{append\PYGZus{}first}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d1}\PYG{p}{,} \PYG{p}{(}\PYG{n}{append\PYGZus{}first}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}}\PYG{n}{offset\PYGZus{}d2}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{l} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{merge\PYGZus{}ind} \PYG{o}{=} \PYG{n}{spit} \PYG{o}{\PYGZhy{}} \PYG{n}{splits}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{n}{ev}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{eit} \PYG{o}{=} \PYG{n}{append\PYGZus{}first}\PYG{p}{;} \PYG{n}{eit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{append\PYGZus{}last}\PYG{p}{;} \PYG{n}{eit} \PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{SplitPolygon} \PYG{n}{sp} \PYG{o}{=} \PYG{n}{SplitPolygon}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sp}\PYG{p}{.}\PYG{n}{init}\PYG{p}{(}\PYG{n}{eit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d1}\PYG{p}{,}\PYG{p}{(}\PYG{n}{eit}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d2}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sp}\PYG{p}{.}\PYG{n}{merge\PYGZus{}ind} \PYG{o}{=} \PYG{n}{merge\PYGZus{}ind}\PYG{p}{;}
                \PYG{n}{splits}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{n}{sp} \PYG{o}{=} \PYG{n}{splits}\PYG{p}{.}\PYG{n}{rbegin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{sp}\PYG{o}{!}\PYG{o}{=}\PYG{n}{splits}\PYG{p}{.}\PYG{n}{rend}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{sp}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{right\PYGZus{}merge}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{merge\PYGZus{}ind} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{splits}\PYG{p}{[}\PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{merge\PYGZus{}ind}\PYG{p}{]}\PYG{p}{.}\PYG{n}{right\PYGZus{}insert}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{right}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{polygons}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{right}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{destroy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{polygons}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}\PYG{c+c1}{//end namespace drclean}
\end{sphinxVerbatim}


\section{CleanerMaster Source}
\label{\detokenize{source_code/cleanermaster_source:cleanermaster-source}}\label{\detokenize{source_code/cleanermaster_source:cmsource}}\label{\detokenize{source_code/cleanermaster_source::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//  This file is part of KLayoutPhotonicPCells, an extension for Photonic Layouts in KLayout.}
\PYG{c+c1}{//  Copyright (c) 2018, Sebastian Goeldi}
\PYG{c+c1}{//}
\PYG{c+c1}{//    This program is free software: you can redistribute it and/or modify}
\PYG{c+c1}{//    it under the terms of the GNU Affero General Public License as}
\PYG{c+c1}{//    published by the Free Software Foundation, either version 3 of the}
\PYG{c+c1}{//    License, or (at your option) any later version.}
\PYG{c+c1}{//}
\PYG{c+c1}{//    This program is distributed in the hope that it will be useful,}
\PYG{c+c1}{//    but WITHOUT ANY WARRANTY; without even the implied warranty of}
\PYG{c+c1}{//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
\PYG{c+c1}{//    GNU Affero General Public License for more details.}
\PYG{c+c1}{//}
\PYG{c+c1}{//    You should have received a copy of the GNU Affero General Public License}
\PYG{c+c1}{//    along with this program.  If not, see \PYGZlt{}https://www.gnu.org/licenses/\PYGZgt{}.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}DrcSl.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}fstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}sstream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}stdexcept\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}boost/interprocess/managed\PYGZus{}shared\PYGZus{}memory.hpp\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}boost/interprocess/containers/vector.hpp\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}boost/interprocess/allocators/allocator.hpp\PYGZgt{}}




\PYG{k}{namespace} \PYG{n}{drclean}
\PYG{p}{\PYGZob{}}

\PYG{c+c1}{//    Function to compare two edgecoord structs. This is necessary for std::sort. If they are on the same coordinate sort for type in descending order}
\PYG{k+kt}{bool} \PYG{n}{compare\PYGZus{}edgecoord}\PYG{p}{(}\PYG{n}{edgecoord} \PYG{n}{e1}\PYG{p}{,} \PYG{n}{edgecoord} \PYG{n}{e2}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{e1}\PYG{p}{.}\PYG{n}{pos}\PYG{o}{=}\PYG{o}{=}\PYG{n}{e2}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{)}
        \PYG{k}{return} \PYG{p}{(}\PYG{n}{e2}\PYG{p}{.}\PYG{n}{type}\PYG{o}{\PYGZlt{}}\PYG{n}{e1}\PYG{p}{.}\PYG{n}{type}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{else}
        \PYG{n+nf}{return} \PYG{p}{(}\PYG{n}{e1}\PYG{p}{.}\PYG{n}{pos}\PYG{o}{\PYGZlt{}}\PYG{n}{e2}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Constructor. Initialize the pointers as nullptrs}
\PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{DrcSl}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Destructor: Delete the allocated vectors.}
\PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{o}{\PYGZti{}}\PYG{n}{DrcSl}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor} \PYG{o}{!}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver} \PYG{o}{!}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Add a complete data\PYGZhy{}set. Currently not used and not exposed in the Python interface.}
\PYG{k+kt}{int} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{set\PYGZus{}data}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{horlist}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l} \PYG{o}{=} \PYG{n}{horlist}\PYG{p}{;}
    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Initialize the dimensions of the vector arrays and set pointers accordingly and dimension units.}
\PYG{k+kt}{void} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{initialize\PYGZus{}list}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{hor1}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{hor2}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{ver1}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{ver2}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{violation\PYGZus{}space}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{violation\PYGZus{}width}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor}\PYG{p}{;}
        \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{delete}\PYG{p}{[}\PYG{p}{]} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver}\PYG{p}{;}
        \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver} \PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor} \PYG{o}{=} \PYG{k}{new} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{n}{ver2}\PYG{o}{\PYGZhy{}}\PYG{n}{ver1}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver} \PYG{o}{=} \PYG{k}{new} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{n}{hor2}\PYG{o}{\PYGZhy{}}\PYG{n}{hor1}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sver} \PYG{o}{=} \PYG{n}{hor2}\PYG{o}{\PYGZhy{}}\PYG{n}{hor1}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{shor} \PYG{o}{=} \PYG{n}{ver2}\PYG{o}{\PYGZhy{}}\PYG{n}{ver1}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hor1} \PYG{o}{=} \PYG{n}{hor1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hor2} \PYG{o}{=} \PYG{n}{hor2}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ver1} \PYG{o}{=} \PYG{n}{ver1}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ver2} \PYG{o}{=} \PYG{n}{ver2}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{violation\PYGZus{}space} \PYG{o}{=} \PYG{n}{violation\PYGZus{}space}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{violation\PYGZus{}width} \PYG{o}{=} \PYG{n}{violation\PYGZus{}width}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{=} \PYG{n}{hor}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Print the complete data set or from index beg \PYGZhy{}\PYGZgt{} end if they are set.}
\PYG{c+c1}{//    \PYGZhy{}1, \PYGZhy{}1 will result in printing the whole vector.}
\PYG{k+kt}{void} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{printvector}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{beg}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{last}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{last} \PYG{o}{=}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{beg} \PYG{o}{=}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{last} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver2} \PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hor2}\PYG{p}{;}
        \PYG{n}{beg} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver1} \PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hor1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it}\PYG{p}{;}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{size, y: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sver} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{size, x: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{shor} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{offset} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nl}{hor1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{ver1}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{offset\PYGZus{}d2} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{hor1}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{beg/end }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{beg}\PYG{o}{+}\PYG{n}{offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{/}\PYG{l+s+sc}{\PYGZsq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{last}\PYG{o}{+}\PYG{n}{offset}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{row: }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{n}{offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{: [}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{n}{it} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}}\PYG{n}{offset\PYGZus{}d2}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{type} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{)}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Get the current array size of the vectors}
\PYG{k+kt}{int} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{sver} \PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{shor}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{//  Sort all data with compare\PYGZus{}edge\PYGZus{}coord and remove overlapping edges, i.e. merge overlapping polygons in the data}
\PYG{k+kt}{void} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sortlist}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+c1}{//        std::cout \PYGZlt{}\PYGZlt{} this\PYGZhy{}\PYGZgt{}s() \PYGZlt{}\PYGZlt{} std::endl;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sort}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{compare\PYGZus{}edgecoord}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it}\PYG{p}{;}
            \PYG{n}{it} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{type} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{c}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{k}{if} \PYG{p}{(}\PYG{n}{c}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{c}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rem} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{if} \PYG{p}{(}\PYG{n}{c}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{1} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{c}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rem} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{c}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{remove\PYGZus{}if}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{auto} \PYG{n}{o}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{o}\PYG{p}{.}\PYG{n}{rem}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Get data from a row (or column).}
\PYG{c+c1}{//    If used after the standard sorting or cleaning function, i.e. sortlist() and cleaning(),}
\PYG{c+c1}{//    the vectors should always be arranged row\PYGZhy{}oriented, meaning the same format as when added to the cleaner.}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{get\PYGZus{}vect}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ind}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{offset} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{hor1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{ver1}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{offset\PYGZus{}d2} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{hor1}\PYG{p}{;}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{res} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{ind}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n}{it} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{ind}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{ind}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{type}\PYG{p}{)}
            \PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{p}{(}\PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{offset\PYGZus{}d2}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{else}
            \PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{=}\PYG{p}{(}\PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{offset\PYGZus{}d2}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Function to print the types in a vector. Probably only useful for debugging purposes}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{get\PYGZus{}types}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{ind}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{offset} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{hor1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{ver1}\PYG{p}{;}

    \PYG{n}{offset} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{res} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{ind}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{i}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n}{it} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{ind}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{ind}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{res}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{type}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{return} \PYG{n}{res}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Add data to the data structure. We manhattanize the edge from the input and mark left facing edges with \PYGZhy{}1 and}
\PYG{c+c1}{//    right facing edges with +1. The get\PYGZus{}vect() function reverses this effect.}
\PYG{c+c1}{//    This should have no influence on any possible data except that it merges touching polygons.}
\PYG{k+kt}{void} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{add\PYGZus{}data}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{px1}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{px2}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{py1}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{py2}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{offset} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nl}{hor1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{ver1}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{offset\PYGZus{}d2} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{hor1}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{py2} \PYG{o}{\PYGZgt{}} \PYG{n}{py1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{edgecoord} \PYG{n}{p}  \PYG{o}{=} \PYG{n}{edgecoord}\PYG{p}{(}\PYG{n}{px1}\PYG{o}{+}\PYG{n}{offset\PYGZus{}d2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kt}{double} \PYG{n}{dx} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{p}{(}\PYG{n}{px2}\PYG{o}{\PYGZhy{}}\PYG{n}{px1}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{py2}\PYG{o}{\PYGZhy{}}\PYG{n}{py1}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{x} \PYG{o}{=} \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{shor} \PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sver}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error ROW (y) index out of bound }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{/}\PYG{l+s+sc}{\PYGZsq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{shor}\PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sver}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{offset}\PYG{o}{+}\PYG{n}{py1} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{py2}\PYG{o}{+}\PYG{n}{offset} \PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{sver} \PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{shor}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error COLUMN (x) index out of bound}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{py2}\PYG{o}{+}\PYG{n}{offset} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{l+m+mi}{2}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{dx} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{offset}\PYG{o}{+}\PYG{n}{py1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{py2}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{x}\PYG{o}{+}\PYG{o}{=}\PYG{n}{dx}\PYG{p}{;}
                \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{=} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{offset}\PYG{o}{+}\PYG{n}{py1}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{py2}\PYG{o}{+}\PYG{n}{offset}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{x}\PYG{o}{+}\PYG{o}{=}\PYG{n}{dx}\PYG{p}{;}
                \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{=} \PYG{k+kt}{int}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{=} \PYG{n}{px2}\PYG{o}{+}\PYG{n}{offset\PYGZus{}d2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{py2}\PYG{o}{+}\PYG{n}{offset}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{py1} \PYG{o}{\PYGZgt{}} \PYG{n}{py2}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{edgecoord} \PYG{n}{p}  \PYG{o}{=} \PYG{n}{edgecoord}\PYG{p}{(}\PYG{n}{px2}\PYG{o}{+}\PYG{n}{offset\PYGZus{}d2}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kt}{double} \PYG{n}{dx} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{double}\PYG{p}{)}\PYG{p}{(}\PYG{n}{px1}\PYG{o}{\PYGZhy{}}\PYG{n}{px2}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{py1}\PYG{o}{\PYGZhy{}}\PYG{n}{py2}\PYG{p}{)}\PYG{p}{;}
        \PYG{k+kt}{double} \PYG{n}{x} \PYG{o}{=} \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{\PYGZgt{}} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{shor} \PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sver}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error ROW (y) index out of bound }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{/}\PYG{l+s+sc}{\PYGZsq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{shor}\PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sver}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{l+m+mi}{1}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{offset}\PYG{o}{+}\PYG{n}{py1} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{py2}\PYG{o}{+}\PYG{n}{offset} \PYG{o}{\PYGZgt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Error COLUMN (x) index out of bound}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
            \PYG{k}{throw} \PYG{l+m+mi}{2}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{dx} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{offset}\PYG{o}{+}\PYG{n}{py2}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{py1}\PYG{o}{+}\PYG{n}{offset}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{x}\PYG{o}{+}\PYG{o}{=}\PYG{n}{dx}\PYG{p}{;}
                \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ceil}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{n}{offset}\PYG{o}{+}\PYG{n}{py2}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{py1}\PYG{o}{+}\PYG{n}{offset}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{x}\PYG{o}{+}\PYG{o}{=}\PYG{n}{dx}\PYG{p}{;}
                \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{ceil}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{n}{p}\PYG{p}{.}\PYG{n}{pos} \PYG{o}{=} \PYG{n}{px1}\PYG{o}{+}\PYG{n}{offset\PYGZus{}d2}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{py1}\PYG{o}{+}\PYG{n}{offset}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Clean data for space violations in the current orientation (row\PYGZhy{}oriented for violations within the row and accordingly if column\PYGZhy{}oriented).}
\PYG{k+kt}{int} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{clean\PYGZus{}space}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+c1}{//Cleans space violations.}
    \PYG{c+c1}{//Returns number of space violations that were cleaned.}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{il} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{;}

    \PYG{c+c1}{//Counters to keep track of how many checks were done and how many space violations have been cleaned.}
    \PYG{k+kt}{int} \PYG{n}{spacevios} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{counts} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{bool} \PYG{n}{er} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{n}{it} \PYG{o}{=} \PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{it} \PYG{o}{=}\PYG{o}{=} \PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{continue}\PYG{p}{;}
            \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{it}\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{o}{!}\PYG{o}{=} \PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{counts}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{it}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZlt{}} \PYG{n}{violation\PYGZus{}space} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{er} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{n}{spacevios}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                    \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rem} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{p}{(}\PYG{n}{it}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rem} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{it}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{er}\PYG{p}{)}
                \PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{remove\PYGZus{}if}\PYG{p}{(}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{auto} \PYG{n}{o}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{o}\PYG{p}{.}\PYG{n}{rem}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{il}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//        If progress output is desired uncomment the following lines}
\PYG{c+c1}{//        std::cout \PYGZlt{}\PYGZlt{} \PYGZdq{}number of checks: \PYGZdq{} \PYGZlt{}\PYGZlt{} counts \PYGZlt{}\PYGZlt{} std::endl;}
\PYG{c+c1}{//        std::cout \PYGZlt{}\PYGZlt{} \PYGZdq{}violations, space: \PYGZdq{} \PYGZlt{}\PYGZlt{} spacevios \PYGZlt{}\PYGZlt{} std::endl;}
    \PYG{k}{return} \PYG{n}{spacevios}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//    Clean data for width violation}
\PYG{k+kt}{int} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{clean\PYGZus{}width}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{il} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{widthvios} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{counts} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it}\PYG{p}{;}

    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{bool} \PYG{n}{er}\PYG{o}{=}\PYG{n+nb}{false}\PYG{p}{;}
            \PYG{n}{it} \PYG{o}{=} \PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{while}\PYG{p}{(}\PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{counts}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{it}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZlt{}} \PYG{n}{violation\PYGZus{}width} \PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{er} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rem} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{p}{(}\PYG{n}{it}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{rem} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{n}{widthvios}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{it}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{er}\PYG{p}{)}
                \PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{remove\PYGZus{}if}\PYG{p}{(}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{auto} \PYG{n}{o}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{return} \PYG{n}{o}\PYG{p}{.}\PYG{n}{rem}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{,}\PYG{n}{il}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

        \PYG{p}{\PYGZcb{}}
        \PYG{n}{il}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//        If progress output is desired uncomment the following lines}
\PYG{c+c1}{//        std::cout \PYGZlt{}\PYGZlt{} \PYGZdq{}number of checks: \PYGZdq{} \PYGZlt{}\PYGZlt{} counts \PYGZlt{}\PYGZlt{} std::endl;}
\PYG{c+c1}{//        std::cout \PYGZlt{}\PYGZlt{} \PYGZdq{}violations, width: \PYGZdq{} \PYGZlt{}\PYGZlt{} widthvios \PYGZlt{}\PYGZlt{} std::endl;}
    \PYG{k}{return} \PYG{n}{widthvios}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{//    Calculate difference between two rows or two columns. This is necessary when switching from row\PYGZhy{}oriented to}
\PYG{c+c1}{//    column\PYGZhy{}oriented data and vice\PYGZhy{}versa.}
\PYG{c+c1}{//}
\PYG{c+c1}{//    In theory this can also be used to check for minimum edge\PYGZhy{}lengths. But for us all of these requirements have been}
\PYG{c+c1}{//    waived, so we don\PYGZsq{}t have to check for those.}
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{listdif}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{l1}\PYG{p}{,} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{o}{\PYGZam{}}\PYG{n}{l2}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/*}
\PYG{c+cm}{    **  Calculates differences between rows (or columns, depending on orientation) between two vectors (rows/columns)}
\PYG{c+cm}{    **  The difference between the two vectors indicate that there is a polygon border for the other orientation of the scanlines}
\PYG{c+cm}{    **  This border corresponds to edges and thus has to appear in the opposite orientation}
\PYG{c+cm}{    */}

    \PYG{c+cm}{/*}
\PYG{c+cm}{    **  Example:}
\PYG{c+cm}{    **}
\PYG{c+cm}{    **  l1 is the row/column that we compare to. Any coordinates that appear in l1, but not in l2, will be returned as ranges.}
\PYG{c+cm}{    **  example:}
\PYG{c+cm}{    **  l1 = ([1,5],[7,10],[18,20])}
\PYG{c+cm}{    **  l2 = ([4,11],[15,16])}
\PYG{c+cm}{    **  out = ([1,3],[18,20])}
\PYG{c+cm}{    */}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{out}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it1} \PYG{o}{=} \PYG{n}{l1}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it2} \PYG{o}{=} \PYG{n}{l2}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{l21}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{l22}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{n}{it1} \PYG{o}{=} \PYG{n}{l1}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it1} \PYG{o}{!}\PYG{o}{=}\PYG{n}{l1}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it1}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{b} \PYG{o}{=} \PYG{n}{it1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{p}{;}
        \PYG{n}{it1}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{e} \PYG{o}{=} \PYG{n}{it1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{ee} \PYG{o}{=} \PYG{n}{e}\PYG{p}{;}
        \PYG{k+kt}{bool} \PYG{n}{add} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{it2} \PYG{o}{!}\PYG{o}{=} \PYG{n}{l2}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{l21} \PYG{o}{=} \PYG{n}{it2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{p}{;}
            \PYG{n}{l22} \PYG{o}{=} \PYG{p}{(}\PYG{n}{it2}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{p}{;}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{l22} \PYG{o}{\PYGZlt{}} \PYG{n}{b}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{it2}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{l22} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{e}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{e} \PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{n}{l21} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{b}\PYG{p}{)}
                    \PYG{n}{add} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{e} \PYG{o}{\PYGZgt{}} \PYG{n}{l21} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
                    \PYG{n}{e} \PYG{o}{=} \PYG{n}{l21} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{l22} \PYG{o}{\PYGZlt{}} \PYG{n}{e} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{l21} \PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{out}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{out}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{l21} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{b} \PYG{o}{=} \PYG{n}{l22} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{n}{e} \PYG{o}{=} \PYG{n}{ee}\PYG{p}{;}
                \PYG{n}{it2} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{l22} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{b} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{b} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{l21}\PYG{p}{)}
                \PYG{n}{b} \PYG{o}{=} \PYG{n}{l22} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
            \PYG{k}{else} \PYG{n+nf}{if} \PYG{p}{(}\PYG{n}{l21} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{e} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{e} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{l22}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{e} \PYG{o}{=} \PYG{n}{l21} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}

        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{add}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{out}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{b}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{out}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{out}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{//    Switch dimensions. When calculating listdiffs between two rows, we can calculate the edges in row direction when}
\PYG{c+c1}{//    row\PYGZhy{}oriented or in column direction when column\PYGZhy{}oriented. These edges then give us column\PYGZhy{}orientation data and vice\PYGZhy{}versa.}
\PYG{k+kt}{void} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{c+cm}{/*}
\PYG{c+cm}{    **  Switch row to column orientation of the scanlines.}
\PYG{c+cm}{    **  Example:}
\PYG{c+cm}{    **}
\PYG{c+cm}{    **  5: 	[]}
\PYG{c+cm}{    **  6: 	[]}
\PYG{c+cm}{    **  7:	[(4,0),(10,1)]}
\PYG{c+cm}{    **  8:	[(3,0),(7,1),(8,0),(11,1)]}
\PYG{c+cm}{    **  9:	[(3,0),(8,1),(8,0),(11,1)]}
\PYG{c+cm}{    **  10:	[(4,0),(8,0),(8,1),(12,1)]}
\PYG{c+cm}{    **  11:	[(4,0),(7,1)]}
\PYG{c+cm}{    **  12:	[]}
\PYG{c+cm}{    **  13:	[]}
\PYG{c+cm}{    **}
\PYG{c+cm}{    **  Will be converted to:}
\PYG{c+cm}{    **}
\PYG{c+cm}{    **  3:	[]}
\PYG{c+cm}{    **  4:	[(7,0),(10,1)]}
\PYG{c+cm}{    **  5:	[(6,0),(12,1)]}
\PYG{c+cm}{    **  6:	[(6,0),(12,1)]}
\PYG{c+cm}{    **  7:	[(6,0),(8,1),(8,0),(11,1)]}
\PYG{c+cm}{    **  8:	[(6,0),(8,1)]}
\PYG{c+cm}{    **  9:	[(6,0),(11,1)]}
\PYG{c+cm}{    **  10:	[(7,0),(11,1)]}
\PYG{c+cm}{    **  11:	[(9,0),(11,1)]}
\PYG{c+cm}{    **  12:	[]}
\PYG{c+cm}{    **}
\PYG{c+cm}{    */}

\PYG{c+c1}{//        If progress output is desired uncomment the following lines}
\PYG{c+c1}{//        std::cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Switching dimensions\PYGZdq{} \PYGZlt{}\PYGZlt{} std::endl;}
    \PYG{k}{if}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
        \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor} \PYG{o}{=} \PYG{k}{new} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ver2}\PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ver1}\PYG{p}{]}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver} \PYG{o}{=}\PYG{o}{=} \PYG{k}{nullptr}\PYG{p}{)}
        \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver} \PYG{o}{=} \PYG{k}{new} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{p}{[}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hor2}\PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hor1}\PYG{p}{]}\PYG{p}{;}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{l\PYGZus{}new}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{shor}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{l\PYGZus{}new} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lhor}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{sver}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{l\PYGZus{}new} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lver}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{n}{row\PYGZus{}last}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{n}{row}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{n}{row\PYGZus{}next}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{it} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{dit}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{dif1}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{n}{dif2}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{edgecoord}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{rit}\PYG{p}{;}
    \PYG{n}{row\PYGZus{}last} \PYG{o}{=} \PYG{o}{*}\PYG{n}{it}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n}{rit} \PYG{o}{=} \PYG{n}{row\PYGZus{}last}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{rit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{row\PYGZus{}last}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{rit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{rit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{rit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{rit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{it} \PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{n}{row} \PYG{o}{=} \PYG{o}{*}\PYG{n}{it}\PYG{p}{;}
    \PYG{k}{for}\PYG{p}{(}\PYG{n}{rit} \PYG{o}{=} \PYG{n}{row}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{rit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{row}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{rit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{rit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{rit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{rit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{row\PYGZus{}number} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;} \PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{n}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{row\PYGZus{}next} \PYG{o}{=} \PYG{o}{*}\PYG{n}{it}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{n}{rit} \PYG{o}{=} \PYG{n}{row\PYGZus{}next}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{rit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{row\PYGZus{}next}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{rit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{rit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{rit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{rit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{n}{dif1} \PYG{o}{=} \PYG{n}{listdif}\PYG{p}{(}\PYG{n}{row\PYGZus{}last}\PYG{p}{,}\PYG{n}{row}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{dif2} \PYG{o}{=} \PYG{n}{listdif}\PYG{p}{(}\PYG{n}{row\PYGZus{}next}\PYG{p}{,}\PYG{n}{row}\PYG{p}{)}\PYG{p}{;}

        \PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{e}\PYG{p}{;}
        \PYG{n}{dit} \PYG{o}{=} \PYG{n}{dif1}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{dit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{dif1}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{b} \PYG{o}{=} \PYG{o}{*}\PYG{n}{dit}\PYG{p}{;}
            \PYG{n}{dit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{e} \PYG{o}{=} \PYG{o}{*}\PYG{n}{dit}\PYG{p}{;}
            \PYG{n}{dit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{k}{for} \PYG{p}{(}\PYG{p}{;} \PYG{n}{b}\PYG{o}{!}\PYG{o}{=}\PYG{n}{e}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{b}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{edgecoord} \PYG{n}{p} \PYG{o}{=} \PYG{n}{edgecoord}\PYG{p}{(}\PYG{n}{row\PYGZus{}number}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{l\PYGZus{}new}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{dit} \PYG{o}{=} \PYG{n}{dif2}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{dit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{dif2}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{b} \PYG{o}{=} \PYG{o}{*}\PYG{n}{dit}\PYG{p}{;}
            \PYG{n}{dit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{n}{e} \PYG{o}{=} \PYG{o}{*}\PYG{n}{dit}\PYG{p}{;}
            \PYG{n}{dit}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
            \PYG{k}{for} \PYG{p}{(}\PYG{p}{;} \PYG{n}{b}\PYG{o}{!}\PYG{o}{=}\PYG{n}{e}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{b}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{edgecoord} \PYG{n}{p} \PYG{o}{=} \PYG{n}{edgecoord}\PYG{p}{(}\PYG{n}{row\PYGZus{}number}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{l\PYGZus{}new}\PYG{p}{[}\PYG{n}{b}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{row\PYGZus{}last} \PYG{o}{=} \PYG{n}{row}\PYG{p}{;}
        \PYG{n}{row} \PYG{o}{=} \PYG{n}{row\PYGZus{}next}\PYG{p}{;}
        \PYG{n}{row\PYGZus{}number}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l} \PYG{o}{=} \PYG{n}{l\PYGZus{}new}\PYG{p}{;}
    \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{orientation} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{n+nl}{hor} \PYG{p}{:} \PYG{n}{ver}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{c+c1}{//    Function that first cleans space violations then width violations and then space violations again.}
\PYG{c+c1}{//    This does not necessarily clean all violations. For example if a fixing of a width violation creates a space violation}
\PYG{c+c1}{//    and vice\PYGZhy{}versa, the algorithm will not fix the violation. For performance reasons}
\PYG{c+c1}{//    it is still the user\PYGZsq{}s task to perform DRC and ensure the design is clean. For standard photonic structures it is}
\PYG{c+c1}{//    unlikely that such a case occurs.}
\PYG{k+kt}{void} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{clean}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{maxtries}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{maxtries}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{clean\PYGZus{}space}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{clean\PYGZus{}space}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{continue}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                    If progress output is desired uncomment the following lines}
\PYG{c+c1}{//                    std::cout\PYGZlt{}\PYGZlt{} \PYGZdq{}Finished after \PYGZdq{} \PYGZlt{}\PYGZlt{} i+1 \PYGZlt{}\PYGZlt{} \PYGZdq{} tries\PYGZdq{} \PYGZlt{}\PYGZlt{} std::endl;}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{maxtries}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{clean\PYGZus{}width}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                If progress output is desired uncomment the following lines}
\PYG{c+c1}{//                std::cout\PYGZlt{}\PYGZlt{} \PYGZdq{}Try: \PYGZdq{} \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} \PYGZdq{}/\PYGZdq{} \PYGZlt{}\PYGZlt{} maxtries \PYGZlt{}\PYGZlt{} std::endl;}
            \PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{clean\PYGZus{}width}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{continue}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                    If progress output is desired uncomment the following lines}
\PYG{c+c1}{//                    std::cout\PYGZlt{}\PYGZlt{} \PYGZdq{}Finished after \PYGZdq{} \PYGZlt{}\PYGZlt{} i+1 \PYGZlt{}\PYGZlt{} \PYGZdq{} tries\PYGZdq{} \PYGZlt{}\PYGZlt{} std::endl;}
                \PYG{k}{break}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{maxtries}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{clean\PYGZus{}space}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                If progress output is desired uncomment the following lines}
\PYG{c+c1}{//                std::cout\PYGZlt{}\PYGZlt{} \PYGZdq{}Try: \PYGZdq{} \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} \PYGZdq{}/\PYGZdq{} \PYGZlt{}\PYGZlt{} maxtries \PYGZlt{}\PYGZlt{} std::endl;}
            \PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{k}{if}\PYG{p}{(}\PYG{n}{clean\PYGZus{}space}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
\PYG{c+c1}{//                        If progress output is desired uncomment the following lines}
\PYG{c+c1}{//                        std::cout\PYGZlt{}\PYGZlt{} \PYGZdq{}Finished after \PYGZdq{} \PYGZlt{}\PYGZlt{} i+1 \PYGZlt{}\PYGZlt{} \PYGZdq{} tries\PYGZdq{} \PYGZlt{}\PYGZlt{} std::endl;}
                    \PYG{n}{switch\PYGZus{}dimensions}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{break}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{//        If progress output is desired uncomment the following lines}
\PYG{c+c1}{//        std::cout\PYGZlt{}\PYGZlt{} \PYGZdq{}Done cleaning\PYGZdq{} \PYGZlt{}\PYGZlt{} std::endl;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{get\PYGZus{}lines}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lines} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{k+kt}{int} \PYG{n}{offset\PYGZus{}d2} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{hor1}\PYG{p}{;}

    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{n+nl}{iter}\PYG{p}{:} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{lines}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{iter}\PYG{p}{.}\PYG{n}{type} \PYG{o}{?} \PYG{n}{iter}\PYG{p}{.}\PYG{n}{pos}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n+nl}{offset\PYGZus{}d2} \PYG{p}{:} \PYG{n}{iter}\PYG{p}{.}\PYG{n}{pos}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{n}{offset\PYGZus{}d2}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{lines}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{pi}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{DrcSl}\PYG{o}{:}\PYG{o}{:}\PYG{n}{get\PYGZus{}polygons}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{splits}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{polygons}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{offset} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nl}{hor1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{ver1}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{offset\PYGZus{}d1} \PYG{o}{=} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{hor1}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{offset\PYGZus{}d2} \PYG{o}{=} \PYG{p}{(}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{orientation} \PYG{o}{?} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ver1} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{hor1}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{;}

    \PYG{k}{for}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;} \PYG{n}{i}\PYG{o}{\PYGZlt{}} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{s}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{y} \PYG{o}{=} \PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{n}{offset}\PYG{p}{;}
        \PYG{k+kt}{bool} \PYG{n}{advance} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
        \PYG{n}{spv}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{spit} \PYG{o}{=} \PYG{n}{splits}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ev}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{append\PYGZus{}first} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ev}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{append\PYGZus{}last} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{for}\PYG{p}{(}\PYG{n}{ev}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{ei} \PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{ei} \PYG{o}{!}\PYG{o}{=} \PYG{k}{this}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{ei}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{x1} \PYG{o}{=} \PYG{n}{ei}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d1}\PYG{p}{;}
            \PYG{k+kt}{int} \PYG{n}{x2} \PYG{o}{=} \PYG{p}{(}\PYG{n}{ei}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d2}\PYG{p}{;}

            \PYG{k}{if}\PYG{p}{(}\PYG{n}{advance}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{spit} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{find\PYGZus{}if}\PYG{p}{(}\PYG{n}{splits}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{splits}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x1}\PYG{p}{,}\PYG{n}{x2}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{offset\PYGZus{}d2}\PYG{p}{,}\PYG{n}{offset\PYGZus{}d1}\PYG{p}{]} \PYG{p}{(}\PYG{n}{SplitPolygon} \PYG{o}{\PYGZam{}} \PYG{n}{sp}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k}{return} \PYG{p}{(}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{end} \PYG{o}{=}\PYG{o}{=}\PYG{n}{y}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{erx} \PYG{o}{\PYGZlt{}} \PYG{n}{x1}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{elx} \PYG{o}{\PYGZgt{}} \PYG{n}{x2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{advance} \PYG{o}{=} \PYG{n+nb}{false}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}

            \PYG{k}{if}\PYG{p}{(}\PYG{n}{spit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{splits}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{int} \PYG{n}{ex1} \PYG{o}{=} \PYG{n}{spit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{elx}\PYG{p}{;}
                \PYG{k+kt}{int} \PYG{n}{ex2} \PYG{o}{=} \PYG{n}{spit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{erx}\PYG{p}{;}

                \PYG{k}{if}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{n}{x1} \PYG{o}{\PYGZgt{}} \PYG{n}{ex2}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{x2} \PYG{o}{\PYGZlt{}} \PYG{n}{ex1}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{spit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end} \PYG{o}{=}\PYG{o}{=} \PYG{n}{y}\PYG{p}{)}
                \PYG{p}{\PYGZob{}}
                    \PYG{k+kt}{int} \PYG{n}{l} \PYG{o}{=} \PYG{n}{append\PYGZus{}last} \PYG{o}{\PYGZhy{}} \PYG{n}{append\PYGZus{}first}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{l} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{spit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{append}\PYG{p}{(}\PYG{n}{append\PYGZus{}first}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d1}\PYG{p}{,} \PYG{p}{(}\PYG{n}{append\PYGZus{}first}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}}\PYG{n}{offset\PYGZus{}d2}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{l} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k+kt}{int} \PYG{n}{merge\PYGZus{}ind} \PYG{o}{=} \PYG{n}{spit} \PYG{o}{\PYGZhy{}} \PYG{n}{splits}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                        \PYG{k}{for}\PYG{p}{(}\PYG{n}{ev}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{eit} \PYG{o}{=} \PYG{n}{append\PYGZus{}first}\PYG{p}{;} \PYG{n}{eit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{append\PYGZus{}last}\PYG{p}{;} \PYG{n}{eit} \PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
                        \PYG{p}{\PYGZob{}}
                            \PYG{n}{SplitPolygon} \PYG{n}{sp} \PYG{o}{=} \PYG{n}{SplitPolygon}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{init}\PYG{p}{(}\PYG{n}{eit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d1}\PYG{p}{,}\PYG{p}{(}\PYG{n}{eit}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d2}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
                            \PYG{n}{sp}\PYG{p}{.}\PYG{n}{merge\PYGZus{}ind} \PYG{o}{=} \PYG{n}{merge\PYGZus{}ind}\PYG{p}{;}
                            \PYG{n}{splits}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{)}\PYG{p}{;}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{n}{spit} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{find\PYGZus{}if}\PYG{p}{(}\PYG{n}{splits}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{splits}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x1}\PYG{p}{,}\PYG{n}{x2}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{offset\PYGZus{}d2}\PYG{p}{,}\PYG{n}{offset\PYGZus{}d1}\PYG{p}{]} \PYG{p}{(}\PYG{n}{SplitPolygon} \PYG{o}{\PYGZam{}} \PYG{n}{sp}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{k}{return} \PYG{p}{(}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{end} \PYG{o}{=}\PYG{o}{=}\PYG{n}{y}\PYG{p}{)} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{p}{(}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{erx} \PYG{o}{\PYGZlt{}} \PYG{n}{x1}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{n}{sp}\PYG{p}{.}\PYG{n}{elx} \PYG{o}{\PYGZgt{}} \PYG{n}{x2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
                    \PYG{k}{if}\PYG{p}{(}\PYG{n}{spit} \PYG{o}{=}\PYG{o}{=} \PYG{n}{splits}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{SplitPolygon} \PYG{n}{sp} \PYG{o}{=} \PYG{n}{SplitPolygon}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{sp}\PYG{p}{.}\PYG{n}{init}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,}\PYG{n}{x2}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{splits}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{)}\PYG{p}{;}
                        \PYG{n}{append\PYGZus{}first} \PYG{o}{=} \PYG{n}{ei} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{;}
                        \PYG{n}{append\PYGZus{}last} \PYG{o}{=} \PYG{n}{ei} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{;}
                        \PYG{n}{advance} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                    \PYG{k}{else}
                    \PYG{p}{\PYGZob{}}
                        \PYG{n}{append\PYGZus{}first} \PYG{o}{=} \PYG{n}{ei}\PYG{p}{;}
                        \PYG{n}{append\PYGZus{}last} \PYG{o}{=} \PYG{n}{ei}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{;}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
                \PYG{k}{else}
                \PYG{p}{\PYGZob{}}
                    \PYG{n}{append\PYGZus{}last} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{else}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{SplitPolygon} \PYG{n}{sp} \PYG{o}{=} \PYG{n}{SplitPolygon}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sp}\PYG{p}{.}\PYG{n}{init}\PYG{p}{(}\PYG{n}{x1}\PYG{p}{,}\PYG{n}{x2}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{splits}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{append\PYGZus{}first} \PYG{o}{=} \PYG{n}{ei} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{;}
                \PYG{n}{append\PYGZus{}last} \PYG{o}{=} \PYG{n}{ei} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{p}{;}
                \PYG{n}{advance} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{k+kt}{int} \PYG{n}{l} \PYG{o}{=} \PYG{n}{append\PYGZus{}last} \PYG{o}{\PYGZhy{}} \PYG{n}{append\PYGZus{}first}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{l} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{spit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{append}\PYG{p}{(}\PYG{n}{append\PYGZus{}first}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d1}\PYG{p}{,} \PYG{p}{(}\PYG{n}{append\PYGZus{}first}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}}\PYG{n}{offset\PYGZus{}d2}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{l} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{2}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{k+kt}{int} \PYG{n}{merge\PYGZus{}ind} \PYG{o}{=} \PYG{n}{spit} \PYG{o}{\PYGZhy{}} \PYG{n}{splits}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{for}\PYG{p}{(}\PYG{n}{ev}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{eit} \PYG{o}{=} \PYG{n}{append\PYGZus{}first}\PYG{p}{;} \PYG{n}{eit} \PYG{o}{!}\PYG{o}{=} \PYG{n}{append\PYGZus{}last}\PYG{p}{;} \PYG{n}{eit} \PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
            \PYG{p}{\PYGZob{}}
                \PYG{n}{SplitPolygon} \PYG{n}{sp} \PYG{o}{=} \PYG{n}{SplitPolygon}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sp}\PYG{p}{.}\PYG{n}{init}\PYG{p}{(}\PYG{n}{eit}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d1}\PYG{p}{,}\PYG{p}{(}\PYG{n}{eit}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{pos} \PYG{o}{\PYGZhy{}} \PYG{n}{offset\PYGZus{}d2}\PYG{p}{,}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{sp}\PYG{p}{.}\PYG{n}{merge\PYGZus{}ind} \PYG{o}{=} \PYG{n}{merge\PYGZus{}ind}\PYG{p}{;}
                \PYG{n}{splits}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{sp}\PYG{p}{)}\PYG{p}{;}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{n}{sp} \PYG{o}{=} \PYG{n}{splits}\PYG{p}{.}\PYG{n}{rbegin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{sp}\PYG{o}{!}\PYG{o}{=}\PYG{n}{splits}\PYG{p}{.}\PYG{n}{rend}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{sp}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{right\PYGZus{}merge}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{merge\PYGZus{}ind} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{splits}\PYG{p}{[}\PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{merge\PYGZus{}ind}\PYG{p}{]}\PYG{p}{.}\PYG{n}{right\PYGZus{}insert}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{right}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{else}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{polygons}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{right}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{sp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{destroy}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{polygons}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}\PYG{c+c1}{//end namespace drclean}
\end{sphinxVerbatim}


\section{CleanerMain Source}
\label{\detokenize{source_code/cleanermain_source:cleanermain-source}}\label{\detokenize{source_code/cleanermain_source:cmainsource}}\label{\detokenize{source_code/cleanermain_source::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//  This file is part of KLayoutPhotonicPCells, an extension for Photonic Layouts in KLayout.}
\PYG{c+c1}{//  Copyright (c) 2018, Sebastian Goeldi}
\PYG{c+c1}{//}
\PYG{c+c1}{//    This program is free software: you can redistribute it and/or modify}
\PYG{c+c1}{//    it under the terms of the GNU Affero General Public License as}
\PYG{c+c1}{//    published by the Free Software Foundation, either version 3 of the}
\PYG{c+c1}{//    License, or (at your option) any later version.}
\PYG{c+c1}{//}
\PYG{c+c1}{//    This program is distributed in the hope that it will be useful,}
\PYG{c+c1}{//    but WITHOUT ANY WARRANTY; without even the implied warranty of}
\PYG{c+c1}{//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
\PYG{c+c1}{//    GNU Affero General Public License for more details.}
\PYG{c+c1}{//}
\PYG{c+c1}{//    You should have received a copy of the GNU Affero General Public License}
\PYG{c+c1}{//    along with this program.  If not, see \PYGZlt{}https://www.gnu.org/licenses/\PYGZgt{}.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}CleanerSlave.h\PYGZdq{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,} \PYG{k+kt}{char}\PYG{o}{*} \PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{drclean}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CleanerSlave}\PYG{o}{*} \PYG{n}{cs}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cs} \PYG{o}{=} \PYG{k}{new} \PYG{n}{drclean}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CleanerSlave}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{argc} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{cs} \PYG{o}{=} \PYG{k}{new} \PYG{n}{drclean}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CleanerSlave}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{stoi}\PYG{p}{(}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    
    
    \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{cs}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{initialized}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{SignalHandler} \PYG{n}{signalHandler}\PYG{p}{;}
    \PYG{n}{signalHandler}\PYG{p}{.}\PYG{n}{setSignalToHandle}\PYG{p}{(}\PYG{n}{SIGUSR1}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{while}\PYG{p}{(}\PYG{o}{!}\PYG{n}{signalHandler}\PYG{p}{.}\PYG{n}{isSignalSet}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{cs}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{clean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//     Cleanup}
    \PYG{n}{cs}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{join\PYGZus{}threads}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{delete} \PYG{n}{cs}\PYG{p}{;}

    \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\section{CleanerSlave Source}
\label{\detokenize{source_code/cleanerslave_source:cleanerslave-source}}\label{\detokenize{source_code/cleanerslave_source:cssource}}\label{\detokenize{source_code/cleanerslave_source::doc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//  This file is part of KLayoutPhotonicPCells, an extension for Photonic Layouts in KLayout.}
\PYG{c+c1}{//  Copyright (c) 2018, Sebastian Goeldi}
\PYG{c+c1}{//}
\PYG{c+c1}{//    This program is free software: you can redistribute it and/or modify}
\PYG{c+c1}{//    it under the terms of the GNU Affero General Public License as}
\PYG{c+c1}{//    published by the Free Software Foundation, either version 3 of the}
\PYG{c+c1}{//    License, or (at your option) any later version.}
\PYG{c+c1}{//}
\PYG{c+c1}{//    This program is distributed in the hope that it will be useful,}
\PYG{c+c1}{//    but WITHOUT ANY WARRANTY; without even the implied warranty of}
\PYG{c+c1}{//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
\PYG{c+c1}{//    GNU Affero General Public License for more details.}
\PYG{c+c1}{//}
\PYG{c+c1}{//    You should have received a copy of the GNU Affero General Public License}
\PYG{c+c1}{//    along with this program.  If not, see \PYGZlt{}https://www.gnu.org/licenses/\PYGZgt{}.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}CleanerSlave.h\PYGZdq{}}


\PYG{k}{namespace} \PYG{n}{drclean}
\PYG{p}{\PYGZob{}}
\PYG{n}{CleanerSlave}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CleanerSlave}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{segment} \PYG{o}{=} \PYG{k}{new} \PYG{n}{bi}\PYG{o}{:}\PYG{o}{:}\PYG{n}{managed\PYGZus{}shared\PYGZus{}memory}\PYG{p}{(}\PYG{n}{bi}\PYG{o}{:}\PYG{o}{:}\PYG{n}{open\PYGZus{}only}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DRCleanEngine}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Initializing}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}

    \PYG{n}{alloc\PYGZus{}inst} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ShmemAllocatorInt}\PYG{p}{(}\PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{get\PYGZus{}segment\PYGZus{}manager}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{alloc\PYGZus{}vec} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ShmemAllocatorIVec}\PYG{p}{(}\PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{get\PYGZus{}segment\PYGZus{}manager}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{alloc\PYGZus{}pvec} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ShmemAllocatorPVec}\PYG{p}{(}\PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{get\PYGZus{}segment\PYGZus{}manager}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{alloc\PYGZus{}poly} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ShmemAllocatorPair}\PYG{p}{(}\PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{get\PYGZus{}segment\PYGZus{}manager}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{input} \PYG{o}{=} \PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{find}\PYG{o}{\PYGZlt{}}\PYG{n}{ShIVector}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{input}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{.}\PYG{n}{first}\PYG{p}{;}
    \PYG{n}{outList} \PYG{o}{=} \PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{find}\PYG{o}{\PYGZlt{}}\PYG{n}{ShIVector}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{outList}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{.}\PYG{n}{first}\PYG{p}{;}

    \PYG{n}{mux\PYGZus{}inp} \PYG{o}{=} \PYG{k}{new} \PYG{n}{bi}\PYG{o}{:}\PYG{o}{:}\PYG{n}{named\PYGZus{}mutex}\PYG{p}{(}\PYG{n}{bi}\PYG{o}{:}\PYG{o}{:}\PYG{n}{open\PYGZus{}only}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mux\PYGZus{}inp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{mux\PYGZus{}out} \PYG{o}{=} \PYG{k}{new} \PYG{n}{bi}\PYG{o}{:}\PYG{o}{:}\PYG{n}{named\PYGZus{}mutex}\PYG{p}{(}\PYG{n}{bi}\PYG{o}{:}\PYG{o}{:}\PYG{n}{open\PYGZus{}only}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mux\PYGZus{}out}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{pool} \PYG{o}{=} \PYG{k}{new} \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{asio}\PYG{o}{:}\PYG{o}{:}\PYG{n}{thread\PYGZus{}pool}\PYG{p}{(}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{k+kr}{thread}\PYG{o}{:}\PYG{o}{:}\PYG{n}{hardware\PYGZus{}concurrency}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{input}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{initialized} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{CleanerSlave}\PYG{o}{:}\PYG{o}{:}\PYG{n}{CleanerSlave}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{nthreads}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{segment} \PYG{o}{=} \PYG{k}{new} \PYG{n}{bi}\PYG{o}{:}\PYG{o}{:}\PYG{n}{managed\PYGZus{}shared\PYGZus{}memory}\PYG{p}{(}\PYG{n}{bi}\PYG{o}{:}\PYG{o}{:}\PYG{n}{open\PYGZus{}only}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{DRCleanEngine}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Initializing}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}

    \PYG{n}{alloc\PYGZus{}inst} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ShmemAllocatorInt}\PYG{p}{(}\PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{get\PYGZus{}segment\PYGZus{}manager}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{alloc\PYGZus{}vec} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ShmemAllocatorIVec}\PYG{p}{(}\PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{get\PYGZus{}segment\PYGZus{}manager}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{alloc\PYGZus{}pvec} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ShmemAllocatorPVec}\PYG{p}{(}\PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{get\PYGZus{}segment\PYGZus{}manager}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{alloc\PYGZus{}poly} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ShmemAllocatorPair}\PYG{p}{(}\PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{get\PYGZus{}segment\PYGZus{}manager}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{input} \PYG{o}{=} \PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{find}\PYG{o}{\PYGZlt{}}\PYG{n}{ShIVector}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{input}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{.}\PYG{n}{first}\PYG{p}{;}
    \PYG{n}{outList} \PYG{o}{=} \PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{find}\PYG{o}{\PYGZlt{}}\PYG{n}{ShIVector}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{outList}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{.}\PYG{n}{first}\PYG{p}{;}

    \PYG{n}{mux\PYGZus{}inp} \PYG{o}{=} \PYG{k}{new} \PYG{n}{bi}\PYG{o}{:}\PYG{o}{:}\PYG{n}{named\PYGZus{}mutex}\PYG{p}{(}\PYG{n}{bi}\PYG{o}{:}\PYG{o}{:}\PYG{n}{open\PYGZus{}only}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mux\PYGZus{}inp}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{mux\PYGZus{}out} \PYG{o}{=} \PYG{k}{new} \PYG{n}{bi}\PYG{o}{:}\PYG{o}{:}\PYG{n}{named\PYGZus{}mutex}\PYG{p}{(}\PYG{n}{bi}\PYG{o}{:}\PYG{o}{:}\PYG{n}{open\PYGZus{}only}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mux\PYGZus{}out}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
    
    \PYG{k+kt}{int} \PYG{n}{n} \PYG{o}{=} \PYG{n}{nthreads}\PYG{p}{;}
    
    \PYG{k}{if}\PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{n} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{n} \PYG{o}{\PYGZgt{}}  \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{k+kr}{thread}\PYG{o}{:}\PYG{o}{:}\PYG{n}{hardware\PYGZus{}concurrency}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{n} \PYG{o}{=} \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{k+kr}{thread}\PYG{o}{:}\PYG{o}{:}\PYG{n}{hardware\PYGZus{}concurrency}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{pool} \PYG{o}{=} \PYG{k}{new} \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{asio}\PYG{o}{:}\PYG{o}{:}\PYG{n}{thread\PYGZus{}pool}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if} \PYG{p}{(}\PYG{n}{input}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{initialized} \PYG{o}{=} \PYG{n+nb}{true}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}

\PYG{n}{CleanerSlave}\PYG{o}{:}\PYG{o}{:}\PYG{o}{\PYGZti{}}\PYG{n}{CleanerSlave}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{join\PYGZus{}threads}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{delete} \PYG{n}{alloc\PYGZus{}inst}\PYG{p}{;}
    \PYG{k}{delete} \PYG{n}{pool}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{CleanerSlave}\PYG{o}{:}\PYG{o}{:}\PYG{n}{clean}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{inp} \PYG{o}{=} \PYG{k}{new} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{mux\PYGZus{}inp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{if}\PYG{p}{(}\PYG{o}{!}\PYG{n}{input}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{bi}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,} \PYG{n}{ShmemAllocatorInt}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{it}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{n}{it} \PYG{o}{=} \PYG{n}{input}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it} \PYG{o}{!}\PYG{o}{=} \PYG{n}{input}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{inp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{o}{*}\PYG{n}{it}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{input}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{mux\PYGZus{}inp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{unlock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{mux\PYGZus{}inp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{unlock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{delete} \PYG{n}{inp}\PYG{p}{;}

        \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{this\PYGZus{}thread}\PYG{o}{:}\PYG{o}{:}\PYG{n}{sleep\PYGZus{}for}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{chrono}\PYG{o}{:}\PYG{o}{:}\PYG{n}{milliseconds}\PYG{p}{(}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{asio}\PYG{o}{:}\PYG{o}{:}\PYG{n}{post}\PYG{p}{(}\PYG{o}{*}\PYG{n}{pool}\PYG{p}{,}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{bind}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{CleanerSlave}\PYG{o}{:}\PYG{o}{:}\PYG{n}{threaded\PYGZus{}DrcSl}\PYG{p}{,}\PYG{k}{this}\PYG{p}{,}\PYG{n}{inp}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{//        threaded\PYGZus{}DrcSl(inp); //For single thread calculation}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{CleanerSlave}\PYG{o}{:}\PYG{o}{:}\PYG{n}{threaded\PYGZus{}DrcSl}\PYG{p}{(}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}} \PYG{o}{*}\PYG{n}{inp}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{int} \PYG{n}{layer}\PYG{p}{;}
    \PYG{k+kt}{int} \PYG{n}{datatype}\PYG{p}{;}

    \PYG{n}{DrcSl} \PYG{n}{sl}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{:}\PYG{o}{:}\PYG{n}{iterator} \PYG{n}{iter} \PYG{o}{=} \PYG{n}{inp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{iter}\PYG{o}{!}\PYG{o}{=}\PYG{n}{inp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{layer} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{datatype} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{n}{iter}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{sl}\PYG{p}{.}\PYG{n}{initialize\PYGZus{}list}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{,}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iter}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iter}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iter}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iter}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iter}\PYG{o}{+}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+c1}{// The first six datapoints are size (x1,x2,y1,y2) and layer, datatype information.}
        \PYG{k+kt}{int} \PYG{n}{count} \PYG{o}{=} \PYG{l+m+mi}{6}\PYG{p}{;}
        \PYG{n}{iter}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{;}
        \PYG{k}{while}\PYG{p}{(}\PYG{n}{iter}\PYG{o}{!}\PYG{o}{=}\PYG{n}{inp}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{count} \PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}
            \PYG{n}{sl}\PYG{p}{.}\PYG{n}{add\PYGZus{}data}\PYG{p}{(}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iter}\PYG{p}{)}\PYG{p}{,}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iter}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iter}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{o}{*}\PYG{p}{(}\PYG{n}{iter}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
            \PYG{n}{iter}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{delete} \PYG{n}{inp}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{delete} \PYG{n}{inp}\PYG{p}{;}
    \PYG{n}{sl}\PYG{p}{.}\PYG{n}{sortlist}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{sl}\PYG{p}{.}\PYG{n}{clean}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string} \PYG{n}{layername} \PYG{o}{=} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{layer}\PYG{p}{)} \PYG{o}{+} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{/}\PYG{l+s}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{to\PYGZus{}string}\PYG{p}{(}\PYG{n}{datatype}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{pi}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}} \PYG{n}{polys} \PYG{o}{=} \PYG{n}{sl}\PYG{p}{.}\PYG{n}{get\PYGZus{}polygons}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{ShPVVector}\PYG{o}{*} \PYG{n}{polygons} \PYG{o}{=} \PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{construct}\PYG{o}{\PYGZlt{}}\PYG{n}{ShPVVector}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{layername}\PYG{p}{.}\PYG{n}{data}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{(}\PYG{o}{*}\PYG{n}{alloc\PYGZus{}pvec}\PYG{p}{)}\PYG{p}{;}

    \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{n+nl}{p}\PYG{p}{:} \PYG{n}{polys}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{ShPVector}\PYG{o}{*} \PYG{n}{poly} \PYG{o}{=} \PYG{n}{segment}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{construct}\PYG{o}{\PYGZlt{}}\PYG{n}{ShPVector}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{bi}\PYG{o}{:}\PYG{o}{:}\PYG{n}{anonymous\PYGZus{}instance}\PYG{p}{)} \PYG{p}{(}\PYG{o}{*}\PYG{n}{alloc\PYGZus{}poly}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{for}\PYG{p}{(}\PYG{k}{auto} \PYG{n+nl}{pit}\PYG{p}{:} \PYG{n}{p}\PYG{p}{)}
        \PYG{p}{\PYGZob{}}
            \PYG{n}{poly}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{pit}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{n}{polygons}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{boost}\PYG{o}{:}\PYG{o}{:}\PYG{n}{move}\PYG{p}{(}\PYG{o}{*}\PYG{n}{poly}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{mux\PYGZus{}out}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{lock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{outList}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{layer}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{outList}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{datatype}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{mux\PYGZus{}out}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{unlock}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n}{CleanerSlave}\PYG{o}{:}\PYG{o}{:}\PYG{n}{join\PYGZus{}threads}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{pool}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{join}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

Glossary:
\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{k}
\item\relax\sphinxstyleindexentry{kppc.drc}\sphinxstyleindexpageref{drc/drc:\detokenize{module-kppc.drc}}
\item\relax\sphinxstyleindexentry{kppc.photonics}\sphinxstyleindexpageref{photonics/photonics:\detokenize{module-kppc.photonics}}
\item\relax\sphinxstyleindexentry{kppc.photonics.dataprep}\sphinxstyleindexpageref{photonics/photonics:\detokenize{module-kppc.photonics.dataprep}}
\item\relax\sphinxstyleindexentry{kppc.photonics.layermaps}\sphinxstyleindexpageref{photonics/photonics:\detokenize{module-kppc.photonics.layermaps}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}